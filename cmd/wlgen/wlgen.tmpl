// Code generated by wlgen. DO NOT EDIT.

package {{.Config.Package}}

import (
	{{range .ExtraImports -}}
		{{. | printf "%q"}}
	{{end -}}
	{{range $k, $v := .Config.Imports -}}
		{{with $v.Name}}{{.}}{{end}} {{$k | printf "%q"}}
	{{end -}}
	"fmt"
	"deedles.dev/wl/wire"
)

{{range $interface := .Protocol.Interfaces}}
	{{- $name := .Name | ident -}}
	{{- $listeners := listeners . -}}
	{{- $senders := senders . -}}

	const (
		{{$name}}Interface = {{.Name | printf "%q"}}
		{{$name}}Version = {{.Version}}
	)

	{{.Description.Full | trimSpace | trimLines | comment -}}
	type {{$name}} struct {
		{{if len $listeners -}}
			Listener interface {
				{{range $listeners -}}
					{{.Description.Full | trimSpace | trimLines | comment -}}
					{{.Name | camel | export}}({{range .Args}}{{.Name | camel | unexport | unkeyword}} {{with .Enum}}{{. | enumType $interface.Name}}{{else}}{{. | goType}}{{end}}, {{end}})

				{{end}}
			}

		{{end}}

		OnDelete func()

		state wire.State
		id uint32
	}

	// New{{$name}} returns a newly instantiated {{$name}}. It is
	// primarily intended for use by generated code.
	func New{{$name}}(state wire.State) *{{$name}} {
		return &{{$name}}{state: state}
	}

	{{if and $.IsClient ($.Locals.Has $interface.Name | not)}}
		func Bind{{$name}}(state wire.State, registry wire.Binder, name, version uint32) *{{$name}} {
			obj := New{{$name}}(state)
			state.Add(obj)
			registry.Bind(name, wire.NewID{Interface: {{$name}}Interface, Version: version, ID: obj.ID()})
			return obj
		}
	{{end}}

	func (obj *{{$name}}) State() wire.State {
		return obj.state
	}

	func (obj *{{$name}}) Dispatch(msg *wire.MessageBuffer) error {
		{{if len $listeners -}}
			switch msg.Op() {
			{{- range $op, $method := $listeners}}
				case {{$op}}:
					{{range $method.Args -}}
						{{- $argName := .Name | camel | unexport | unkeyword -}}

						{{if and (eq .Type "object") .Interface}}
							{{- $type := .Interface | ident -}}

							{{$argName}}ID := msg.ReadUint()
							{{$argName}} := {{$type | package}}New{{$type | trimPackage}}(obj.state)
							obj.state.Set({{$argName}}ID, {{$argName}})
						{{else}}
							{{if .Enum}}
								{{$argName}} := {{.Enum | enumType $interface.Name}}(msg.Read{{. | typeFuncSuffix}}())
							{{else}}
								{{$argName}} := msg.Read{{. | typeFuncSuffix}}()
							{{end}}
						{{end}}
					{{end -}}
					if err := msg.Err(); err != nil {
						return err
					}

					if obj.Listener == nil {
						return nil
					}
					obj.Listener.{{.Name | camel | export}}(
						{{range $method.Args -}}
							{{.Name | camel | unexport | unkeyword}},
						{{end -}}
					)
					return nil
			{{end -}}
			}

		{{end}}
		return wire.UnknownOpError{
			Interface: {{.Name | printf "%q"}},
			Type: {{if $.IsClient -}} "event" {{- else -}} "request" {{- end}},
			Op: msg.Op(),
		}
	}

	func (obj *{{$name}}) ID() uint32 {
		return obj.id
	}

	func (obj *{{$name}}) SetID(id uint32) {
		obj.id = id
	}

	func (obj *{{$name}}) Delete() {
		if obj.OnDelete != nil {
			obj.OnDelete()
		}
	}

	func (obj *{{$name}}) String() string {
		return fmt.Sprintf("%v(%v)", {{$interface.Name | printf "%q"}}, obj.id)
	}

	func (obj *{{$name}}) MethodName(op uint16) string {
		switch op {
		{{- range $op, $method := $listeners}}
			case {{$op}}:
				return {{$method.Name | printf "%q"}}
		{{end -}}
		}

		return "unknown method"
	}

	{{range $op, $method := $senders}}
		{{- $args := args $method -}}
		{{- $rets := returns $method -}}

		{{$method.Description.Full | trimSpace | trimLines | comment -}}
		func (obj *{{$name}}) {{$method.Name | camel | export}}({{range $args}}{{.Name | camel | unexport | unkeyword}} {{with .Enum}}{{. | enumType $interface.Name}}{{else}}{{. | goType}}{{end}}, {{end}}) ({{range $rets}}{{.Name | camel | unexport | unkeyword}} *{{.Interface | ident}}, {{end}}) {
		builder := wire.NewMessage(obj, {{$op}})
			builder.Method = {{$method.Name | printf "%q"}}
			builder.Args = []any{ {{- range $method.Args}}{{.Name | camel | unexport | unkeyword}}, {{end -}} }

			{{range $method.Args -}}
				{{if isRet . -}}
					{{.Name | camel | unexport | unkeyword}} = New{{.Interface | ident}}(obj.state)
					obj.state.Add({{.Name | camel | unexport | unkeyword}})
					builder.WriteObject({{.Name | camel | unexport | unkeyword}})
				{{else -}}
					builder.Write{{. | typeFuncSuffix}}({{if .Enum}}{{. | goType}}({{end}}{{.Name | camel | unexport | unkeyword}}{{if .Enum}}){{end}})
				{{end -}}
			{{end}}

			obj.state.Enqueue(builder)
			return {{range $i, $_ := $rets}}{{if $i}}, {{end}}{{.Name | camel | unexport | unkeyword}}{{end}}
		}
	{{end}}

	{{range $enum := .Enums}}
		{{- $enumName := .Name | enumType $interface.Name -}}

		{{$enum.Description.Full | trimSpace | trimLines | comment -}}
		type {{$enumName}} int64

		const (
			{{range .Entries -}}
				{{.Summary | trimSpace | trimLines | comment -}}
				{{$enumName}}{{.Name | camel | export}} {{$enumName}} = {{.Int}}

			{{end}}
		)

		func (enum {{$enumName}}) String() string {
			switch enum {
			{{- range .Entries}}
				case {{.Int}}: return {{printf "%s%s" $enumName (.Name | camel | export) | printf "%q"}}
			{{end -}}
			}

			return {{printf "<invalid %s>" $enumName | printf "%q"}}
		}
	{{end}}
{{end}}
