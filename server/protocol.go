// Code generated by wlgen. DO NOT EDIT.

package wl

import (
	"deedles.dev/wl/wire"
	"fmt"
	"os"
)

const (
	DisplayInterface = "wl_display"
	DisplayVersion   = 1
)

// DisplayListener is a type that can respond to incoming
// messages for a Display object.
type DisplayListener interface {
	// The sync request asks the server to emit the 'done' event
	// on the returned wl_callback object.  Since requests are
	// handled in-order and events are delivered in-order, this can
	// be used as a barrier to ensure all previous requests and the
	// resulting events have been handled.
	//
	// The object returned by this request will be destroyed by the
	// compositor after the callback is fired and as such the client must not
	// attempt to use it after that point.
	//
	// The callback_data passed in the callback is the event serial.
	Sync(callback *Callback)

	// This request creates a registry object that allows the client
	// to list and bind the global objects available from the
	// compositor.
	//
	// It should be noted that the server side resources consumed in
	// response to a get_registry request can only be released when the
	// client disconnects, not when the client side proxy is destroyed.
	// Therefore, clients should invoke get_registry as infrequently as
	// possible to avoid wasting memory.
	GetRegistry(registry *Registry)
}

// The core global object.  This is a special singleton object.  It
// is used for internal Wayland protocol features.
type Display struct {
	// Listener's methods are called by incoming messages from the
	// remote end via Dispatch. If it is nil, messages are silently
	// ignored.
	Listener DisplayListener

	// OnDelete is called when the object is removed from the tracking
	// system.
	OnDelete func()

	state wire.State
	id    uint32
}

// NewDisplay returns a newly instantiated Display. It is
// primarily intended for use by generated code.
func NewDisplay(state wire.State) *Display {
	return &Display{state: state}
}

func (obj *Display) State() wire.State {
	return obj.state
}

func (obj *Display) Dispatch(msg *wire.MessageBuffer) error {
	switch msg.Op() {
	case 0:
		callback := NewCallback(obj.state)
		callback.SetID(msg.ReadUint())
		obj.state.Add(callback)

		if err := msg.Err(); err != nil {
			return err
		}

		if obj.Listener == nil {
			return nil
		}
		obj.Listener.Sync(
			callback,
		)
		return nil

	case 1:
		registry := NewRegistry(obj.state)
		registry.SetID(msg.ReadUint())
		obj.state.Add(registry)

		if err := msg.Err(); err != nil {
			return err
		}

		if obj.Listener == nil {
			return nil
		}
		obj.Listener.GetRegistry(
			registry,
		)
		return nil
	}

	return wire.UnknownOpError{
		Interface: "wl_display",
		Type:      "request",
		Op:        msg.Op(),
	}
}

func (obj *Display) ID() uint32 {
	return obj.id
}

func (obj *Display) SetID(id uint32) {
	obj.id = id
}

func (obj *Display) Delete() {
	if obj.OnDelete != nil {
		obj.OnDelete()
	}
}

func (obj *Display) String() string {
	return fmt.Sprintf("%v(%v)", "wl_display", obj.id)
}

func (obj *Display) MethodName(op uint16) string {
	switch op {
	case 0:
		return "sync"

	case 1:
		return "get_registry"
	}

	return "unknown method"
}

func (obj *Display) Interface() string {
	return DisplayInterface
}

func (obj *Display) Version() uint32 {
	return DisplayVersion
}

// The error event is sent out when a fatal (non-recoverable)
// error has occurred.  The object_id argument is the object
// where the error occurred, most often in response to a request
// to that object.  The code identifies the error and is defined
// by the object interface.  As such, each interface defines its
// own set of error codes.  The message is a brief description
// of the error, for (debugging) convenience.
func (obj *Display) Error(objectId uint32, code uint32, message string) {
	builder := wire.NewMessage(obj, 0)
	builder.Method = "error"
	builder.Args = []any{objectId, code, message}

	builder.WriteUint(objectId)
	builder.WriteUint(code)
	builder.WriteString(message)

	obj.state.Enqueue(builder)
	return
}

// This event is used internally by the object ID management
// logic. When a client deletes an object that it had created,
// the server will send this event to acknowledge that it has
// seen the delete request. When the client receives this event,
// it will know that it can safely reuse the object ID.
func (obj *Display) DeleteId(id uint32) {
	builder := wire.NewMessage(obj, 1)
	builder.Method = "delete_id"
	builder.Args = []any{id}

	builder.WriteUint(id)

	obj.state.Enqueue(builder)
	return
}

// These errors are global and can be emitted in response to any
// server request.
type DisplayError int64

const (
	// server couldn't find object
	DisplayErrorInvalidObject DisplayError = 0

	// method doesn't exist on the specified interface or malformed request
	DisplayErrorInvalidMethod DisplayError = 1

	// server is out of memory
	DisplayErrorNoMemory DisplayError = 2

	// implementation error in compositor
	DisplayErrorImplementation DisplayError = 3
)

func (enum DisplayError) String() string {
	switch enum {
	case 0:
		return "DisplayErrorInvalidObject"

	case 1:
		return "DisplayErrorInvalidMethod"

	case 2:
		return "DisplayErrorNoMemory"

	case 3:
		return "DisplayErrorImplementation"
	}

	return "<invalid DisplayError>"
}

const (
	RegistryInterface = "wl_registry"
	RegistryVersion   = 1
)

// RegistryListener is a type that can respond to incoming
// messages for a Registry object.
type RegistryListener interface {
	// Binds a new, client-created object to the server using the
	// specified name as the identifier.
	Bind(name uint32, id wire.NewID)
}

// The singleton global registry object.  The server has a number of
// global objects that are available to all clients.  These objects
// typically represent an actual object in the server (for example,
// an input device) or they are singleton objects that provide
// extension functionality.
//
// When a client creates a registry object, the registry object
// will emit a global event for each global currently in the
// registry.  Globals come and go as a result of device or
// monitor hotplugs, reconfiguration or other events, and the
// registry will send out global and global_remove events to
// keep the client up to date with the changes.  To mark the end
// of the initial burst of events, the client can use the
// wl_display.sync request immediately after calling
// wl_display.get_registry.
//
// A client can bind to a global object by using the bind
// request.  This creates a client-side handle that lets the object
// emit events to the client and lets the client invoke requests on
// the object.
type Registry struct {
	// Listener's methods are called by incoming messages from the
	// remote end via Dispatch. If it is nil, messages are silently
	// ignored.
	Listener RegistryListener

	// OnDelete is called when the object is removed from the tracking
	// system.
	OnDelete func()

	state wire.State
	id    uint32
}

// NewRegistry returns a newly instantiated Registry. It is
// primarily intended for use by generated code.
func NewRegistry(state wire.State) *Registry {
	return &Registry{state: state}
}

func (obj *Registry) State() wire.State {
	return obj.state
}

func (obj *Registry) Dispatch(msg *wire.MessageBuffer) error {
	switch msg.Op() {
	case 0:

		name := msg.ReadUint()

		id := msg.ReadNewID()

		if err := msg.Err(); err != nil {
			return err
		}

		if obj.Listener == nil {
			return nil
		}
		obj.Listener.Bind(
			name,
			id,
		)
		return nil
	}

	return wire.UnknownOpError{
		Interface: "wl_registry",
		Type:      "request",
		Op:        msg.Op(),
	}
}

func (obj *Registry) ID() uint32 {
	return obj.id
}

func (obj *Registry) SetID(id uint32) {
	obj.id = id
}

func (obj *Registry) Delete() {
	if obj.OnDelete != nil {
		obj.OnDelete()
	}
}

func (obj *Registry) String() string {
	return fmt.Sprintf("%v(%v)", "wl_registry", obj.id)
}

func (obj *Registry) MethodName(op uint16) string {
	switch op {
	case 0:
		return "bind"
	}

	return "unknown method"
}

func (obj *Registry) Interface() string {
	return RegistryInterface
}

func (obj *Registry) Version() uint32 {
	return RegistryVersion
}

// Notify the client of global objects.
//
// The event notifies the client that a global object with
// the given name is now available, and it implements the
// given version of the given interface.
func (obj *Registry) Global(name uint32, _interface string, version uint32) {
	builder := wire.NewMessage(obj, 0)
	builder.Method = "global"
	builder.Args = []any{name, _interface, version}

	builder.WriteUint(name)
	builder.WriteString(_interface)
	builder.WriteUint(version)

	obj.state.Enqueue(builder)
	return
}

// Notify the client of removed global objects.
//
// This event notifies the client that the global identified
// by name is no longer available.  If the client bound to
// the global using the bind request, the client should now
// destroy that object.
//
// The object remains valid and requests to the object will be
// ignored until the client destroys it, to avoid races between
// the global going away and a client sending a request to it.
func (obj *Registry) GlobalRemove(name uint32) {
	builder := wire.NewMessage(obj, 1)
	builder.Method = "global_remove"
	builder.Args = []any{name}

	builder.WriteUint(name)

	obj.state.Enqueue(builder)
	return
}

const (
	CallbackInterface = "wl_callback"
	CallbackVersion   = 1
)

// Clients can handle the 'done' event to get notified when
// the related request is done.
type Callback struct {

	// OnDelete is called when the object is removed from the tracking
	// system.
	OnDelete func()

	state wire.State
	id    uint32
}

// NewCallback returns a newly instantiated Callback. It is
// primarily intended for use by generated code.
func NewCallback(state wire.State) *Callback {
	return &Callback{state: state}
}

func (obj *Callback) State() wire.State {
	return obj.state
}

func (obj *Callback) Dispatch(msg *wire.MessageBuffer) error {

	return wire.UnknownOpError{
		Interface: "wl_callback",
		Type:      "request",
		Op:        msg.Op(),
	}
}

func (obj *Callback) ID() uint32 {
	return obj.id
}

func (obj *Callback) SetID(id uint32) {
	obj.id = id
}

func (obj *Callback) Delete() {
	if obj.OnDelete != nil {
		obj.OnDelete()
	}
}

func (obj *Callback) String() string {
	return fmt.Sprintf("%v(%v)", "wl_callback", obj.id)
}

func (obj *Callback) MethodName(op uint16) string {
	switch op {
	}

	return "unknown method"
}

func (obj *Callback) Interface() string {
	return CallbackInterface
}

func (obj *Callback) Version() uint32 {
	return CallbackVersion
}

// Notify the client when the related request is done.
func (obj *Callback) Done(callbackData uint32) {
	builder := wire.NewMessage(obj, 0)
	builder.Method = "done"
	builder.Args = []any{callbackData}

	builder.WriteUint(callbackData)

	obj.state.Enqueue(builder)
	return
}

const (
	CompositorInterface = "wl_compositor"
	CompositorVersion   = 4
)

// CompositorListener is a type that can respond to incoming
// messages for a Compositor object.
type CompositorListener interface {
	// Ask the compositor to create a new surface.
	CreateSurface(id *Surface)

	// Ask the compositor to create a new region.
	CreateRegion(id *Region)
}

// A compositor.  This object is a singleton global.  The
// compositor is in charge of combining the contents of multiple
// surfaces into one displayable output.
type Compositor struct {
	// Listener's methods are called by incoming messages from the
	// remote end via Dispatch. If it is nil, messages are silently
	// ignored.
	Listener CompositorListener

	// OnDelete is called when the object is removed from the tracking
	// system.
	OnDelete func()

	state wire.State
	id    uint32
}

// NewCompositor returns a newly instantiated Compositor. It is
// primarily intended for use by generated code.
func NewCompositor(state wire.State) *Compositor {
	return &Compositor{state: state}
}

func BindCompositor(state wire.State, id wire.NewID) *Compositor {
	obj := NewCompositor(state)
	obj.SetID(id.ID)
	state.Add(obj)
	return obj
}

func (obj *Compositor) State() wire.State {
	return obj.state
}

func (obj *Compositor) Dispatch(msg *wire.MessageBuffer) error {
	switch msg.Op() {
	case 0:
		id := NewSurface(obj.state)
		id.SetID(msg.ReadUint())
		obj.state.Add(id)

		if err := msg.Err(); err != nil {
			return err
		}

		if obj.Listener == nil {
			return nil
		}
		obj.Listener.CreateSurface(
			id,
		)
		return nil

	case 1:
		id := NewRegion(obj.state)
		id.SetID(msg.ReadUint())
		obj.state.Add(id)

		if err := msg.Err(); err != nil {
			return err
		}

		if obj.Listener == nil {
			return nil
		}
		obj.Listener.CreateRegion(
			id,
		)
		return nil
	}

	return wire.UnknownOpError{
		Interface: "wl_compositor",
		Type:      "request",
		Op:        msg.Op(),
	}
}

func (obj *Compositor) ID() uint32 {
	return obj.id
}

func (obj *Compositor) SetID(id uint32) {
	obj.id = id
}

func (obj *Compositor) Delete() {
	if obj.OnDelete != nil {
		obj.OnDelete()
	}
}

func (obj *Compositor) String() string {
	return fmt.Sprintf("%v(%v)", "wl_compositor", obj.id)
}

func (obj *Compositor) MethodName(op uint16) string {
	switch op {
	case 0:
		return "create_surface"

	case 1:
		return "create_region"
	}

	return "unknown method"
}

func (obj *Compositor) Interface() string {
	return CompositorInterface
}

func (obj *Compositor) Version() uint32 {
	return CompositorVersion
}

const (
	ShmPoolInterface = "wl_shm_pool"
	ShmPoolVersion   = 1
)

// ShmPoolListener is a type that can respond to incoming
// messages for a ShmPool object.
type ShmPoolListener interface {
	// Create a wl_buffer object from the pool.
	//
	// The buffer is created offset bytes into the pool and has
	// width and height as specified.  The stride argument specifies
	// the number of bytes from the beginning of one row to the beginning
	// of the next.  The format is the pixel format of the buffer and
	// must be one of those advertised through the wl_shm.format event.
	//
	// A buffer will keep a reference to the pool it was created from
	// so it is valid to destroy the pool immediately after creating
	// a buffer from it.
	CreateBuffer(id *Buffer, offset int32, width int32, height int32, stride int32, format ShmFormat)

	// Destroy the shared memory pool.
	//
	// The mmapped memory will be released when all
	// buffers that have been created from this pool
	// are gone.
	Destroy()

	// This request will cause the server to remap the backing memory
	// for the pool from the file descriptor passed when the pool was
	// created, but using the new size.  This request can only be
	// used to make the pool bigger.
	Resize(size int32)
}

// The wl_shm_pool object encapsulates a piece of memory shared
// between the compositor and client.  Through the wl_shm_pool
// object, the client can allocate shared memory wl_buffer objects.
// All objects created through the same pool share the same
// underlying mapped memory. Reusing the mapped memory avoids the
// setup/teardown overhead and is useful when interactively resizing
// a surface or for many small buffers.
type ShmPool struct {
	// Listener's methods are called by incoming messages from the
	// remote end via Dispatch. If it is nil, messages are silently
	// ignored.
	Listener ShmPoolListener

	// OnDelete is called when the object is removed from the tracking
	// system.
	OnDelete func()

	state wire.State
	id    uint32
}

// NewShmPool returns a newly instantiated ShmPool. It is
// primarily intended for use by generated code.
func NewShmPool(state wire.State) *ShmPool {
	return &ShmPool{state: state}
}

func (obj *ShmPool) State() wire.State {
	return obj.state
}

func (obj *ShmPool) Dispatch(msg *wire.MessageBuffer) error {
	switch msg.Op() {
	case 0:
		id := NewBuffer(obj.state)
		id.SetID(msg.ReadUint())
		obj.state.Add(id)

		offset := msg.ReadInt()

		width := msg.ReadInt()

		height := msg.ReadInt()

		stride := msg.ReadInt()

		format := ShmFormat(msg.ReadUint())

		if err := msg.Err(); err != nil {
			return err
		}

		if obj.Listener == nil {
			return nil
		}
		obj.Listener.CreateBuffer(
			id,
			offset,
			width,
			height,
			stride,
			format,
		)
		return nil

	case 1:
		if err := msg.Err(); err != nil {
			return err
		}

		if obj.Listener == nil {
			return nil
		}
		obj.Listener.Destroy()
		return nil

	case 2:

		size := msg.ReadInt()

		if err := msg.Err(); err != nil {
			return err
		}

		if obj.Listener == nil {
			return nil
		}
		obj.Listener.Resize(
			size,
		)
		return nil
	}

	return wire.UnknownOpError{
		Interface: "wl_shm_pool",
		Type:      "request",
		Op:        msg.Op(),
	}
}

func (obj *ShmPool) ID() uint32 {
	return obj.id
}

func (obj *ShmPool) SetID(id uint32) {
	obj.id = id
}

func (obj *ShmPool) Delete() {
	if obj.OnDelete != nil {
		obj.OnDelete()
	}
}

func (obj *ShmPool) String() string {
	return fmt.Sprintf("%v(%v)", "wl_shm_pool", obj.id)
}

func (obj *ShmPool) MethodName(op uint16) string {
	switch op {
	case 0:
		return "create_buffer"

	case 1:
		return "destroy"

	case 2:
		return "resize"
	}

	return "unknown method"
}

func (obj *ShmPool) Interface() string {
	return ShmPoolInterface
}

func (obj *ShmPool) Version() uint32 {
	return ShmPoolVersion
}

const (
	ShmInterface = "wl_shm"
	ShmVersion   = 1
)

// ShmListener is a type that can respond to incoming
// messages for a Shm object.
type ShmListener interface {
	// Create a new wl_shm_pool object.
	//
	// The pool can be used to create shared memory based buffer
	// objects.  The server will mmap size bytes of the passed file
	// descriptor, to use as backing memory for the pool.
	CreatePool(id *ShmPool, fd *os.File, size int32)
}

// A singleton global object that provides support for shared
// memory.
//
// Clients can create wl_shm_pool objects using the create_pool
// request.
//
// At connection setup time, the wl_shm object emits one or more
// format events to inform clients about the valid pixel formats
// that can be used for buffers.
type Shm struct {
	// Listener's methods are called by incoming messages from the
	// remote end via Dispatch. If it is nil, messages are silently
	// ignored.
	Listener ShmListener

	// OnDelete is called when the object is removed from the tracking
	// system.
	OnDelete func()

	state wire.State
	id    uint32
}

// NewShm returns a newly instantiated Shm. It is
// primarily intended for use by generated code.
func NewShm(state wire.State) *Shm {
	return &Shm{state: state}
}

func BindShm(state wire.State, id wire.NewID) *Shm {
	obj := NewShm(state)
	obj.SetID(id.ID)
	state.Add(obj)
	return obj
}

func (obj *Shm) State() wire.State {
	return obj.state
}

func (obj *Shm) Dispatch(msg *wire.MessageBuffer) error {
	switch msg.Op() {
	case 0:
		id := NewShmPool(obj.state)
		id.SetID(msg.ReadUint())
		obj.state.Add(id)

		fd := msg.ReadFile()

		size := msg.ReadInt()

		if err := msg.Err(); err != nil {
			return err
		}

		if obj.Listener == nil {
			return nil
		}
		obj.Listener.CreatePool(
			id,
			fd,
			size,
		)
		return nil
	}

	return wire.UnknownOpError{
		Interface: "wl_shm",
		Type:      "request",
		Op:        msg.Op(),
	}
}

func (obj *Shm) ID() uint32 {
	return obj.id
}

func (obj *Shm) SetID(id uint32) {
	obj.id = id
}

func (obj *Shm) Delete() {
	if obj.OnDelete != nil {
		obj.OnDelete()
	}
}

func (obj *Shm) String() string {
	return fmt.Sprintf("%v(%v)", "wl_shm", obj.id)
}

func (obj *Shm) MethodName(op uint16) string {
	switch op {
	case 0:
		return "create_pool"
	}

	return "unknown method"
}

func (obj *Shm) Interface() string {
	return ShmInterface
}

func (obj *Shm) Version() uint32 {
	return ShmVersion
}

// Informs the client about a valid pixel format that
// can be used for buffers. Known formats include
// argb8888 and xrgb8888.
func (obj *Shm) Format(format ShmFormat) {
	builder := wire.NewMessage(obj, 0)
	builder.Method = "format"
	builder.Args = []any{format}

	builder.WriteUint(uint32(format))

	obj.state.Enqueue(builder)
	return
}

// These errors can be emitted in response to wl_shm requests.
type ShmError int64

const (
	// buffer format is not known
	ShmErrorInvalidFormat ShmError = 0

	// invalid size or stride during pool or buffer creation
	ShmErrorInvalidStride ShmError = 1

	// mmapping the file descriptor failed
	ShmErrorInvalidFd ShmError = 2
)

func (enum ShmError) String() string {
	switch enum {
	case 0:
		return "ShmErrorInvalidFormat"

	case 1:
		return "ShmErrorInvalidStride"

	case 2:
		return "ShmErrorInvalidFd"
	}

	return "<invalid ShmError>"
}

// This describes the memory layout of an individual pixel.
//
// All renderers should support argb8888 and xrgb8888 but any other
// formats are optional and may not be supported by the particular
// renderer in use.
//
// The drm format codes match the macros defined in drm_fourcc.h, except
// argb8888 and xrgb8888. The formats actually supported by the compositor
// will be reported by the format event.
type ShmFormat int64

const (
	// 32-bit ARGB format, [31:0] A:R:G:B 8:8:8:8 little endian
	ShmFormatArgb8888 ShmFormat = 0

	// 32-bit RGB format, [31:0] x:R:G:B 8:8:8:8 little endian
	ShmFormatXrgb8888 ShmFormat = 1

	// 8-bit color index format, [7:0] C
	ShmFormatC8 ShmFormat = 538982467

	// 8-bit RGB format, [7:0] R:G:B 3:3:2
	ShmFormatRgb332 ShmFormat = 943867730

	// 8-bit BGR format, [7:0] B:G:R 2:3:3
	ShmFormatBgr233 ShmFormat = 944916290

	// 16-bit xRGB format, [15:0] x:R:G:B 4:4:4:4 little endian
	ShmFormatXrgb4444 ShmFormat = 842093144

	// 16-bit xBGR format, [15:0] x:B:G:R 4:4:4:4 little endian
	ShmFormatXbgr4444 ShmFormat = 842089048

	// 16-bit RGBx format, [15:0] R:G:B:x 4:4:4:4 little endian
	ShmFormatRgbx4444 ShmFormat = 842094674

	// 16-bit BGRx format, [15:0] B:G:R:x 4:4:4:4 little endian
	ShmFormatBgrx4444 ShmFormat = 842094658

	// 16-bit ARGB format, [15:0] A:R:G:B 4:4:4:4 little endian
	ShmFormatArgb4444 ShmFormat = 842093121

	// 16-bit ABGR format, [15:0] A:B:G:R 4:4:4:4 little endian
	ShmFormatAbgr4444 ShmFormat = 842089025

	// 16-bit RBGA format, [15:0] R:G:B:A 4:4:4:4 little endian
	ShmFormatRgba4444 ShmFormat = 842088786

	// 16-bit BGRA format, [15:0] B:G:R:A 4:4:4:4 little endian
	ShmFormatBgra4444 ShmFormat = 842088770

	// 16-bit xRGB format, [15:0] x:R:G:B 1:5:5:5 little endian
	ShmFormatXrgb1555 ShmFormat = 892424792

	// 16-bit xBGR 1555 format, [15:0] x:B:G:R 1:5:5:5 little endian
	ShmFormatXbgr1555 ShmFormat = 892420696

	// 16-bit RGBx 5551 format, [15:0] R:G:B:x 5:5:5:1 little endian
	ShmFormatRgbx5551 ShmFormat = 892426322

	// 16-bit BGRx 5551 format, [15:0] B:G:R:x 5:5:5:1 little endian
	ShmFormatBgrx5551 ShmFormat = 892426306

	// 16-bit ARGB 1555 format, [15:0] A:R:G:B 1:5:5:5 little endian
	ShmFormatArgb1555 ShmFormat = 892424769

	// 16-bit ABGR 1555 format, [15:0] A:B:G:R 1:5:5:5 little endian
	ShmFormatAbgr1555 ShmFormat = 892420673

	// 16-bit RGBA 5551 format, [15:0] R:G:B:A 5:5:5:1 little endian
	ShmFormatRgba5551 ShmFormat = 892420434

	// 16-bit BGRA 5551 format, [15:0] B:G:R:A 5:5:5:1 little endian
	ShmFormatBgra5551 ShmFormat = 892420418

	// 16-bit RGB 565 format, [15:0] R:G:B 5:6:5 little endian
	ShmFormatRgb565 ShmFormat = 909199186

	// 16-bit BGR 565 format, [15:0] B:G:R 5:6:5 little endian
	ShmFormatBgr565 ShmFormat = 909199170

	// 24-bit RGB format, [23:0] R:G:B little endian
	ShmFormatRgb888 ShmFormat = 875710290

	// 24-bit BGR format, [23:0] B:G:R little endian
	ShmFormatBgr888 ShmFormat = 875710274

	// 32-bit xBGR format, [31:0] x:B:G:R 8:8:8:8 little endian
	ShmFormatXbgr8888 ShmFormat = 875709016

	// 32-bit RGBx format, [31:0] R:G:B:x 8:8:8:8 little endian
	ShmFormatRgbx8888 ShmFormat = 875714642

	// 32-bit BGRx format, [31:0] B:G:R:x 8:8:8:8 little endian
	ShmFormatBgrx8888 ShmFormat = 875714626

	// 32-bit ABGR format, [31:0] A:B:G:R 8:8:8:8 little endian
	ShmFormatAbgr8888 ShmFormat = 875708993

	// 32-bit RGBA format, [31:0] R:G:B:A 8:8:8:8 little endian
	ShmFormatRgba8888 ShmFormat = 875708754

	// 32-bit BGRA format, [31:0] B:G:R:A 8:8:8:8 little endian
	ShmFormatBgra8888 ShmFormat = 875708738

	// 32-bit xRGB format, [31:0] x:R:G:B 2:10:10:10 little endian
	ShmFormatXrgb2101010 ShmFormat = 808669784

	// 32-bit xBGR format, [31:0] x:B:G:R 2:10:10:10 little endian
	ShmFormatXbgr2101010 ShmFormat = 808665688

	// 32-bit RGBx format, [31:0] R:G:B:x 10:10:10:2 little endian
	ShmFormatRgbx1010102 ShmFormat = 808671314

	// 32-bit BGRx format, [31:0] B:G:R:x 10:10:10:2 little endian
	ShmFormatBgrx1010102 ShmFormat = 808671298

	// 32-bit ARGB format, [31:0] A:R:G:B 2:10:10:10 little endian
	ShmFormatArgb2101010 ShmFormat = 808669761

	// 32-bit ABGR format, [31:0] A:B:G:R 2:10:10:10 little endian
	ShmFormatAbgr2101010 ShmFormat = 808665665

	// 32-bit RGBA format, [31:0] R:G:B:A 10:10:10:2 little endian
	ShmFormatRgba1010102 ShmFormat = 808665426

	// 32-bit BGRA format, [31:0] B:G:R:A 10:10:10:2 little endian
	ShmFormatBgra1010102 ShmFormat = 808665410

	// packed YCbCr format, [31:0] Cr0:Y1:Cb0:Y0 8:8:8:8 little endian
	ShmFormatYuyv ShmFormat = 1448695129

	// packed YCbCr format, [31:0] Cb0:Y1:Cr0:Y0 8:8:8:8 little endian
	ShmFormatYvyu ShmFormat = 1431918169

	// packed YCbCr format, [31:0] Y1:Cr0:Y0:Cb0 8:8:8:8 little endian
	ShmFormatUyvy ShmFormat = 1498831189

	// packed YCbCr format, [31:0] Y1:Cb0:Y0:Cr0 8:8:8:8 little endian
	ShmFormatVyuy ShmFormat = 1498765654

	// packed AYCbCr format, [31:0] A:Y:Cb:Cr 8:8:8:8 little endian
	ShmFormatAyuv ShmFormat = 1448433985

	// 2 plane YCbCr Cr:Cb format, 2x2 subsampled Cr:Cb plane
	ShmFormatNv12 ShmFormat = 842094158

	// 2 plane YCbCr Cb:Cr format, 2x2 subsampled Cb:Cr plane
	ShmFormatNv21 ShmFormat = 825382478

	// 2 plane YCbCr Cr:Cb format, 2x1 subsampled Cr:Cb plane
	ShmFormatNv16 ShmFormat = 909203022

	// 2 plane YCbCr Cb:Cr format, 2x1 subsampled Cb:Cr plane
	ShmFormatNv61 ShmFormat = 825644622

	// 3 plane YCbCr format, 4x4 subsampled Cb (1) and Cr (2) planes
	ShmFormatYuv410 ShmFormat = 961959257

	// 3 plane YCbCr format, 4x4 subsampled Cr (1) and Cb (2) planes
	ShmFormatYvu410 ShmFormat = 961893977

	// 3 plane YCbCr format, 4x1 subsampled Cb (1) and Cr (2) planes
	ShmFormatYuv411 ShmFormat = 825316697

	// 3 plane YCbCr format, 4x1 subsampled Cr (1) and Cb (2) planes
	ShmFormatYvu411 ShmFormat = 825316953

	// 3 plane YCbCr format, 2x2 subsampled Cb (1) and Cr (2) planes
	ShmFormatYuv420 ShmFormat = 842093913

	// 3 plane YCbCr format, 2x2 subsampled Cr (1) and Cb (2) planes
	ShmFormatYvu420 ShmFormat = 842094169

	// 3 plane YCbCr format, 2x1 subsampled Cb (1) and Cr (2) planes
	ShmFormatYuv422 ShmFormat = 909202777

	// 3 plane YCbCr format, 2x1 subsampled Cr (1) and Cb (2) planes
	ShmFormatYvu422 ShmFormat = 909203033

	// 3 plane YCbCr format, non-subsampled Cb (1) and Cr (2) planes
	ShmFormatYuv444 ShmFormat = 875713881

	// 3 plane YCbCr format, non-subsampled Cr (1) and Cb (2) planes
	ShmFormatYvu444 ShmFormat = 875714137

	// [7:0] R
	ShmFormatR8 ShmFormat = 538982482

	// [15:0] R little endian
	ShmFormatR16 ShmFormat = 540422482

	// [15:0] R:G 8:8 little endian
	ShmFormatRg88 ShmFormat = 943212370

	// [15:0] G:R 8:8 little endian
	ShmFormatGr88 ShmFormat = 943215175

	// [31:0] R:G 16:16 little endian
	ShmFormatRg1616 ShmFormat = 842221394

	// [31:0] G:R 16:16 little endian
	ShmFormatGr1616 ShmFormat = 842224199

	// [63:0] x:R:G:B 16:16:16:16 little endian
	ShmFormatXrgb16161616f ShmFormat = 1211388504

	// [63:0] x:B:G:R 16:16:16:16 little endian
	ShmFormatXbgr16161616f ShmFormat = 1211384408

	// [63:0] A:R:G:B 16:16:16:16 little endian
	ShmFormatArgb16161616f ShmFormat = 1211388481

	// [63:0] A:B:G:R 16:16:16:16 little endian
	ShmFormatAbgr16161616f ShmFormat = 1211384385

	// [31:0] X:Y:Cb:Cr 8:8:8:8 little endian
	ShmFormatXyuv8888 ShmFormat = 1448434008

	// [23:0] Cr:Cb:Y 8:8:8 little endian
	ShmFormatVuy888 ShmFormat = 875713878

	// Y followed by U then V, 10:10:10. Non-linear modifier only
	ShmFormatVuy101010 ShmFormat = 808670550

	// [63:0] Cr0:0:Y1:0:Cb0:0:Y0:0 10:6:10:6:10:6:10:6 little endian per 2 Y pixels
	ShmFormatY210 ShmFormat = 808530521

	// [63:0] Cr0:0:Y1:0:Cb0:0:Y0:0 12:4:12:4:12:4:12:4 little endian per 2 Y pixels
	ShmFormatY212 ShmFormat = 842084953

	// [63:0] Cr0:Y1:Cb0:Y0 16:16:16:16 little endian per 2 Y pixels
	ShmFormatY216 ShmFormat = 909193817

	// [31:0] A:Cr:Y:Cb 2:10:10:10 little endian
	ShmFormatY410 ShmFormat = 808531033

	// [63:0] A:0:Cr:0:Y:0:Cb:0 12:4:12:4:12:4:12:4 little endian
	ShmFormatY412 ShmFormat = 842085465

	// [63:0] A:Cr:Y:Cb 16:16:16:16 little endian
	ShmFormatY416 ShmFormat = 909194329

	// [31:0] X:Cr:Y:Cb 2:10:10:10 little endian
	ShmFormatXvyu2101010 ShmFormat = 808670808

	// [63:0] X:0:Cr:0:Y:0:Cb:0 12:4:12:4:12:4:12:4 little endian
	ShmFormatXvyu1216161616 ShmFormat = 909334104

	// [63:0] X:Cr:Y:Cb 16:16:16:16 little endian
	ShmFormatXvyu16161616 ShmFormat = 942954072

	// [63:0]   A3:A2:Y3:0:Cr0:0:Y2:0:A1:A0:Y1:0:Cb0:0:Y0:0  1:1:8:2:8:2:8:2:1:1:8:2:8:2:8:2 little endian
	ShmFormatY0l0 ShmFormat = 810299481

	// [63:0]   X3:X2:Y3:0:Cr0:0:Y2:0:X1:X0:Y1:0:Cb0:0:Y0:0  1:1:8:2:8:2:8:2:1:1:8:2:8:2:8:2 little endian
	ShmFormatX0l0 ShmFormat = 810299480

	// [63:0]   A3:A2:Y3:Cr0:Y2:A1:A0:Y1:Cb0:Y0  1:1:10:10:10:1:1:10:10:10 little endian
	ShmFormatY0l2 ShmFormat = 843853913

	// [63:0]   X3:X2:Y3:Cr0:Y2:X1:X0:Y1:Cb0:Y0  1:1:10:10:10:1:1:10:10:10 little endian
	ShmFormatX0l2 ShmFormat = 843853912

	ShmFormatYuv4208bit ShmFormat = 942691673

	ShmFormatYuv42010bit ShmFormat = 808539481

	ShmFormatXrgb8888A8 ShmFormat = 943805016

	ShmFormatXbgr8888A8 ShmFormat = 943800920

	ShmFormatRgbx8888A8 ShmFormat = 943806546

	ShmFormatBgrx8888A8 ShmFormat = 943806530

	ShmFormatRgb888A8 ShmFormat = 943798354

	ShmFormatBgr888A8 ShmFormat = 943798338

	ShmFormatRgb565A8 ShmFormat = 943797586

	ShmFormatBgr565A8 ShmFormat = 943797570

	// non-subsampled Cr:Cb plane
	ShmFormatNv24 ShmFormat = 875714126

	// non-subsampled Cb:Cr plane
	ShmFormatNv42 ShmFormat = 842290766

	// 2x1 subsampled Cr:Cb plane, 10 bit per channel
	ShmFormatP210 ShmFormat = 808530512

	// 2x2 subsampled Cr:Cb plane 10 bits per channel
	ShmFormatP010 ShmFormat = 808530000

	// 2x2 subsampled Cr:Cb plane 12 bits per channel
	ShmFormatP012 ShmFormat = 842084432

	// 2x2 subsampled Cr:Cb plane 16 bits per channel
	ShmFormatP016 ShmFormat = 909193296

	// [63:0] A:x:B:x:G:x:R:x 10:6:10:6:10:6:10:6 little endian
	ShmFormatAxbxgxrx106106106106 ShmFormat = 808534593

	// 2x2 subsampled Cr:Cb plane
	ShmFormatNv15 ShmFormat = 892425806

	ShmFormatQ410 ShmFormat = 808531025

	ShmFormatQ401 ShmFormat = 825242705
)

func (enum ShmFormat) String() string {
	switch enum {
	case 0:
		return "ShmFormatArgb8888"

	case 1:
		return "ShmFormatXrgb8888"

	case 538982467:
		return "ShmFormatC8"

	case 943867730:
		return "ShmFormatRgb332"

	case 944916290:
		return "ShmFormatBgr233"

	case 842093144:
		return "ShmFormatXrgb4444"

	case 842089048:
		return "ShmFormatXbgr4444"

	case 842094674:
		return "ShmFormatRgbx4444"

	case 842094658:
		return "ShmFormatBgrx4444"

	case 842093121:
		return "ShmFormatArgb4444"

	case 842089025:
		return "ShmFormatAbgr4444"

	case 842088786:
		return "ShmFormatRgba4444"

	case 842088770:
		return "ShmFormatBgra4444"

	case 892424792:
		return "ShmFormatXrgb1555"

	case 892420696:
		return "ShmFormatXbgr1555"

	case 892426322:
		return "ShmFormatRgbx5551"

	case 892426306:
		return "ShmFormatBgrx5551"

	case 892424769:
		return "ShmFormatArgb1555"

	case 892420673:
		return "ShmFormatAbgr1555"

	case 892420434:
		return "ShmFormatRgba5551"

	case 892420418:
		return "ShmFormatBgra5551"

	case 909199186:
		return "ShmFormatRgb565"

	case 909199170:
		return "ShmFormatBgr565"

	case 875710290:
		return "ShmFormatRgb888"

	case 875710274:
		return "ShmFormatBgr888"

	case 875709016:
		return "ShmFormatXbgr8888"

	case 875714642:
		return "ShmFormatRgbx8888"

	case 875714626:
		return "ShmFormatBgrx8888"

	case 875708993:
		return "ShmFormatAbgr8888"

	case 875708754:
		return "ShmFormatRgba8888"

	case 875708738:
		return "ShmFormatBgra8888"

	case 808669784:
		return "ShmFormatXrgb2101010"

	case 808665688:
		return "ShmFormatXbgr2101010"

	case 808671314:
		return "ShmFormatRgbx1010102"

	case 808671298:
		return "ShmFormatBgrx1010102"

	case 808669761:
		return "ShmFormatArgb2101010"

	case 808665665:
		return "ShmFormatAbgr2101010"

	case 808665426:
		return "ShmFormatRgba1010102"

	case 808665410:
		return "ShmFormatBgra1010102"

	case 1448695129:
		return "ShmFormatYuyv"

	case 1431918169:
		return "ShmFormatYvyu"

	case 1498831189:
		return "ShmFormatUyvy"

	case 1498765654:
		return "ShmFormatVyuy"

	case 1448433985:
		return "ShmFormatAyuv"

	case 842094158:
		return "ShmFormatNv12"

	case 825382478:
		return "ShmFormatNv21"

	case 909203022:
		return "ShmFormatNv16"

	case 825644622:
		return "ShmFormatNv61"

	case 961959257:
		return "ShmFormatYuv410"

	case 961893977:
		return "ShmFormatYvu410"

	case 825316697:
		return "ShmFormatYuv411"

	case 825316953:
		return "ShmFormatYvu411"

	case 842093913:
		return "ShmFormatYuv420"

	case 842094169:
		return "ShmFormatYvu420"

	case 909202777:
		return "ShmFormatYuv422"

	case 909203033:
		return "ShmFormatYvu422"

	case 875713881:
		return "ShmFormatYuv444"

	case 875714137:
		return "ShmFormatYvu444"

	case 538982482:
		return "ShmFormatR8"

	case 540422482:
		return "ShmFormatR16"

	case 943212370:
		return "ShmFormatRg88"

	case 943215175:
		return "ShmFormatGr88"

	case 842221394:
		return "ShmFormatRg1616"

	case 842224199:
		return "ShmFormatGr1616"

	case 1211388504:
		return "ShmFormatXrgb16161616f"

	case 1211384408:
		return "ShmFormatXbgr16161616f"

	case 1211388481:
		return "ShmFormatArgb16161616f"

	case 1211384385:
		return "ShmFormatAbgr16161616f"

	case 1448434008:
		return "ShmFormatXyuv8888"

	case 875713878:
		return "ShmFormatVuy888"

	case 808670550:
		return "ShmFormatVuy101010"

	case 808530521:
		return "ShmFormatY210"

	case 842084953:
		return "ShmFormatY212"

	case 909193817:
		return "ShmFormatY216"

	case 808531033:
		return "ShmFormatY410"

	case 842085465:
		return "ShmFormatY412"

	case 909194329:
		return "ShmFormatY416"

	case 808670808:
		return "ShmFormatXvyu2101010"

	case 909334104:
		return "ShmFormatXvyu1216161616"

	case 942954072:
		return "ShmFormatXvyu16161616"

	case 810299481:
		return "ShmFormatY0l0"

	case 810299480:
		return "ShmFormatX0l0"

	case 843853913:
		return "ShmFormatY0l2"

	case 843853912:
		return "ShmFormatX0l2"

	case 942691673:
		return "ShmFormatYuv4208bit"

	case 808539481:
		return "ShmFormatYuv42010bit"

	case 943805016:
		return "ShmFormatXrgb8888A8"

	case 943800920:
		return "ShmFormatXbgr8888A8"

	case 943806546:
		return "ShmFormatRgbx8888A8"

	case 943806530:
		return "ShmFormatBgrx8888A8"

	case 943798354:
		return "ShmFormatRgb888A8"

	case 943798338:
		return "ShmFormatBgr888A8"

	case 943797586:
		return "ShmFormatRgb565A8"

	case 943797570:
		return "ShmFormatBgr565A8"

	case 875714126:
		return "ShmFormatNv24"

	case 842290766:
		return "ShmFormatNv42"

	case 808530512:
		return "ShmFormatP210"

	case 808530000:
		return "ShmFormatP010"

	case 842084432:
		return "ShmFormatP012"

	case 909193296:
		return "ShmFormatP016"

	case 808534593:
		return "ShmFormatAxbxgxrx106106106106"

	case 892425806:
		return "ShmFormatNv15"

	case 808531025:
		return "ShmFormatQ410"

	case 825242705:
		return "ShmFormatQ401"
	}

	return "<invalid ShmFormat>"
}

const (
	BufferInterface = "wl_buffer"
	BufferVersion   = 1
)

// BufferListener is a type that can respond to incoming
// messages for a Buffer object.
type BufferListener interface {
	// Destroy a buffer. If and how you need to release the backing
	// storage is defined by the buffer factory interface.
	//
	// For possible side-effects to a surface, see wl_surface.attach.
	Destroy()
}

// A buffer provides the content for a wl_surface. Buffers are
// created through factory interfaces such as wl_drm, wl_shm or
// similar. It has a width and a height and can be attached to a
// wl_surface, but the mechanism by which a client provides and
// updates the contents is defined by the buffer factory interface.
type Buffer struct {
	// Listener's methods are called by incoming messages from the
	// remote end via Dispatch. If it is nil, messages are silently
	// ignored.
	Listener BufferListener

	// OnDelete is called when the object is removed from the tracking
	// system.
	OnDelete func()

	state wire.State
	id    uint32
}

// NewBuffer returns a newly instantiated Buffer. It is
// primarily intended for use by generated code.
func NewBuffer(state wire.State) *Buffer {
	return &Buffer{state: state}
}

func (obj *Buffer) State() wire.State {
	return obj.state
}

func (obj *Buffer) Dispatch(msg *wire.MessageBuffer) error {
	switch msg.Op() {
	case 0:
		if err := msg.Err(); err != nil {
			return err
		}

		if obj.Listener == nil {
			return nil
		}
		obj.Listener.Destroy()
		return nil
	}

	return wire.UnknownOpError{
		Interface: "wl_buffer",
		Type:      "request",
		Op:        msg.Op(),
	}
}

func (obj *Buffer) ID() uint32 {
	return obj.id
}

func (obj *Buffer) SetID(id uint32) {
	obj.id = id
}

func (obj *Buffer) Delete() {
	if obj.OnDelete != nil {
		obj.OnDelete()
	}
}

func (obj *Buffer) String() string {
	return fmt.Sprintf("%v(%v)", "wl_buffer", obj.id)
}

func (obj *Buffer) MethodName(op uint16) string {
	switch op {
	case 0:
		return "destroy"
	}

	return "unknown method"
}

func (obj *Buffer) Interface() string {
	return BufferInterface
}

func (obj *Buffer) Version() uint32 {
	return BufferVersion
}

// Sent when this wl_buffer is no longer used by the compositor.
// The client is now free to reuse or destroy this buffer and its
// backing storage.
//
// If a client receives a release event before the frame callback
// requested in the same wl_surface.commit that attaches this
// wl_buffer to a surface, then the client is immediately free to
// reuse the buffer and its backing storage, and does not need a
// second buffer for the next surface content update. Typically
// this is possible, when the compositor maintains a copy of the
// wl_surface contents, e.g. as a GL texture. This is an important
// optimization for GL(ES) compositors with wl_shm clients.
func (obj *Buffer) Release() {
	builder := wire.NewMessage(obj, 0)
	builder.Method = "release"
	builder.Args = []any{}

	obj.state.Enqueue(builder)
	return
}

const (
	DataOfferInterface = "wl_data_offer"
	DataOfferVersion   = 3
)

// DataOfferListener is a type that can respond to incoming
// messages for a DataOffer object.
type DataOfferListener interface {
	// Indicate that the client can accept the given mime type, or
	// NULL for not accepted.
	//
	// For objects of version 2 or older, this request is used by the
	// client to give feedback whether the client can receive the given
	// mime type, or NULL if none is accepted; the feedback does not
	// determine whether the drag-and-drop operation succeeds or not.
	//
	// For objects of version 3 or newer, this request determines the
	// final result of the drag-and-drop operation. If the end result
	// is that no mime types were accepted, the drag-and-drop operation
	// will be cancelled and the corresponding drag source will receive
	// wl_data_source.cancelled. Clients may still use this event in
	// conjunction with wl_data_source.action for feedback.
	Accept(serial uint32, mimeType string)

	// To transfer the offered data, the client issues this request
	// and indicates the mime type it wants to receive.  The transfer
	// happens through the passed file descriptor (typically created
	// with the pipe system call).  The source client writes the data
	// in the mime type representation requested and then closes the
	// file descriptor.
	//
	// The receiving client reads from the read end of the pipe until
	// EOF and then closes its end, at which point the transfer is
	// complete.
	//
	// This request may happen multiple times for different mime types,
	// both before and after wl_data_device.drop. Drag-and-drop destination
	// clients may preemptively fetch data or examine it more closely to
	// determine acceptance.
	Receive(mimeType string, fd *os.File)

	// Destroy the data offer.
	Destroy()

	// Notifies the compositor that the drag destination successfully
	// finished the drag-and-drop operation.
	//
	// Upon receiving this request, the compositor will emit
	// wl_data_source.dnd_finished on the drag source client.
	//
	// It is a client error to perform other requests than
	// wl_data_offer.destroy after this one. It is also an error to perform
	// this request after a NULL mime type has been set in
	// wl_data_offer.accept or no action was received through
	// wl_data_offer.action.
	//
	// If wl_data_offer.finish request is received for a non drag and drop
	// operation, the invalid_finish protocol error is raised.
	Finish()

	// Sets the actions that the destination side client supports for
	// this operation. This request may trigger the emission of
	// wl_data_source.action and wl_data_offer.action events if the compositor
	// needs to change the selected action.
	//
	// This request can be called multiple times throughout the
	// drag-and-drop operation, typically in response to wl_data_device.enter
	// or wl_data_device.motion events.
	//
	// This request determines the final result of the drag-and-drop
	// operation. If the end result is that no action is accepted,
	// the drag source will receive wl_data_source.cancelled.
	//
	// The dnd_actions argument must contain only values expressed in the
	// wl_data_device_manager.dnd_actions enum, and the preferred_action
	// argument must only contain one of those values set, otherwise it
	// will result in a protocol error.
	//
	// While managing an "ask" action, the destination drag-and-drop client
	// may perform further wl_data_offer.receive requests, and is expected
	// to perform one last wl_data_offer.set_actions request with a preferred
	// action other than "ask" (and optionally wl_data_offer.accept) before
	// requesting wl_data_offer.finish, in order to convey the action selected
	// by the user. If the preferred action is not in the
	// wl_data_offer.source_actions mask, an error will be raised.
	//
	// If the "ask" action is dismissed (e.g. user cancellation), the client
	// is expected to perform wl_data_offer.destroy right away.
	//
	// This request can only be made on drag-and-drop offers, a protocol error
	// will be raised otherwise.
	SetActions(dndActions DataDeviceManagerDndAction, preferredAction DataDeviceManagerDndAction)
}

// A wl_data_offer represents a piece of data offered for transfer
// by another client (the source client).  It is used by the
// copy-and-paste and drag-and-drop mechanisms.  The offer
// describes the different mime types that the data can be
// converted to and provides the mechanism for transferring the
// data directly from the source client.
type DataOffer struct {
	// Listener's methods are called by incoming messages from the
	// remote end via Dispatch. If it is nil, messages are silently
	// ignored.
	Listener DataOfferListener

	// OnDelete is called when the object is removed from the tracking
	// system.
	OnDelete func()

	state wire.State
	id    uint32
}

// NewDataOffer returns a newly instantiated DataOffer. It is
// primarily intended for use by generated code.
func NewDataOffer(state wire.State) *DataOffer {
	return &DataOffer{state: state}
}

func (obj *DataOffer) State() wire.State {
	return obj.state
}

func (obj *DataOffer) Dispatch(msg *wire.MessageBuffer) error {
	switch msg.Op() {
	case 0:

		serial := msg.ReadUint()

		mimeType := msg.ReadString()

		if err := msg.Err(); err != nil {
			return err
		}

		if obj.Listener == nil {
			return nil
		}
		obj.Listener.Accept(
			serial,
			mimeType,
		)
		return nil

	case 1:

		mimeType := msg.ReadString()

		fd := msg.ReadFile()

		if err := msg.Err(); err != nil {
			return err
		}

		if obj.Listener == nil {
			return nil
		}
		obj.Listener.Receive(
			mimeType,
			fd,
		)
		return nil

	case 2:
		if err := msg.Err(); err != nil {
			return err
		}

		if obj.Listener == nil {
			return nil
		}
		obj.Listener.Destroy()
		return nil

	case 3:
		if err := msg.Err(); err != nil {
			return err
		}

		if obj.Listener == nil {
			return nil
		}
		obj.Listener.Finish()
		return nil

	case 4:

		dndActions := DataDeviceManagerDndAction(msg.ReadUint())

		preferredAction := DataDeviceManagerDndAction(msg.ReadUint())

		if err := msg.Err(); err != nil {
			return err
		}

		if obj.Listener == nil {
			return nil
		}
		obj.Listener.SetActions(
			dndActions,
			preferredAction,
		)
		return nil
	}

	return wire.UnknownOpError{
		Interface: "wl_data_offer",
		Type:      "request",
		Op:        msg.Op(),
	}
}

func (obj *DataOffer) ID() uint32 {
	return obj.id
}

func (obj *DataOffer) SetID(id uint32) {
	obj.id = id
}

func (obj *DataOffer) Delete() {
	if obj.OnDelete != nil {
		obj.OnDelete()
	}
}

func (obj *DataOffer) String() string {
	return fmt.Sprintf("%v(%v)", "wl_data_offer", obj.id)
}

func (obj *DataOffer) MethodName(op uint16) string {
	switch op {
	case 0:
		return "accept"

	case 1:
		return "receive"

	case 2:
		return "destroy"

	case 3:
		return "finish"

	case 4:
		return "set_actions"
	}

	return "unknown method"
}

func (obj *DataOffer) Interface() string {
	return DataOfferInterface
}

func (obj *DataOffer) Version() uint32 {
	return DataOfferVersion
}

// Sent immediately after creating the wl_data_offer object.  One
// event per offered mime type.
func (obj *DataOffer) Offer(mimeType string) {
	builder := wire.NewMessage(obj, 0)
	builder.Method = "offer"
	builder.Args = []any{mimeType}

	builder.WriteString(mimeType)

	obj.state.Enqueue(builder)
	return
}

// This event indicates the actions offered by the data source. It
// will be sent right after wl_data_device.enter, or anytime the source
// side changes its offered actions through wl_data_source.set_actions.
func (obj *DataOffer) SourceActions(sourceActions DataDeviceManagerDndAction) {
	builder := wire.NewMessage(obj, 1)
	builder.Method = "source_actions"
	builder.Args = []any{sourceActions}

	builder.WriteUint(uint32(sourceActions))

	obj.state.Enqueue(builder)
	return
}

// This event indicates the action selected by the compositor after
// matching the source/destination side actions. Only one action (or
// none) will be offered here.
//
// This event can be emitted multiple times during the drag-and-drop
// operation in response to destination side action changes through
// wl_data_offer.set_actions.
//
// This event will no longer be emitted after wl_data_device.drop
// happened on the drag-and-drop destination, the client must
// honor the last action received, or the last preferred one set
// through wl_data_offer.set_actions when handling an "ask" action.
//
// Compositors may also change the selected action on the fly, mainly
// in response to keyboard modifier changes during the drag-and-drop
// operation.
//
// The most recent action received is always the valid one. Prior to
// receiving wl_data_device.drop, the chosen action may change (e.g.
// due to keyboard modifiers being pressed). At the time of receiving
// wl_data_device.drop the drag-and-drop destination must honor the
// last action received.
//
// Action changes may still happen after wl_data_device.drop,
// especially on "ask" actions, where the drag-and-drop destination
// may choose another action afterwards. Action changes happening
// at this stage are always the result of inter-client negotiation, the
// compositor shall no longer be able to induce a different action.
//
// Upon "ask" actions, it is expected that the drag-and-drop destination
// may potentially choose a different action and/or mime type,
// based on wl_data_offer.source_actions and finally chosen by the
// user (e.g. popping up a menu with the available options). The
// final wl_data_offer.set_actions and wl_data_offer.accept requests
// must happen before the call to wl_data_offer.finish.
func (obj *DataOffer) Action(dndAction DataDeviceManagerDndAction) {
	builder := wire.NewMessage(obj, 2)
	builder.Method = "action"
	builder.Args = []any{dndAction}

	builder.WriteUint(uint32(dndAction))

	obj.state.Enqueue(builder)
	return
}

type DataOfferError int64

const (
	// finish request was called untimely
	DataOfferErrorInvalidFinish DataOfferError = 0

	// action mask contains invalid values
	DataOfferErrorInvalidActionMask DataOfferError = 1

	// action argument has an invalid value
	DataOfferErrorInvalidAction DataOfferError = 2

	// offer doesn't accept this request
	DataOfferErrorInvalidOffer DataOfferError = 3
)

func (enum DataOfferError) String() string {
	switch enum {
	case 0:
		return "DataOfferErrorInvalidFinish"

	case 1:
		return "DataOfferErrorInvalidActionMask"

	case 2:
		return "DataOfferErrorInvalidAction"

	case 3:
		return "DataOfferErrorInvalidOffer"
	}

	return "<invalid DataOfferError>"
}

const (
	DataSourceInterface = "wl_data_source"
	DataSourceVersion   = 3
)

// DataSourceListener is a type that can respond to incoming
// messages for a DataSource object.
type DataSourceListener interface {
	// This request adds a mime type to the set of mime types
	// advertised to targets.  Can be called several times to offer
	// multiple types.
	Offer(mimeType string)

	// Destroy the data source.
	Destroy()

	// Sets the actions that the source side client supports for this
	// operation. This request may trigger wl_data_source.action and
	// wl_data_offer.action events if the compositor needs to change the
	// selected action.
	//
	// The dnd_actions argument must contain only values expressed in the
	// wl_data_device_manager.dnd_actions enum, otherwise it will result
	// in a protocol error.
	//
	// This request must be made once only, and can only be made on sources
	// used in drag-and-drop, so it must be performed before
	// wl_data_device.start_drag. Attempting to use the source other than
	// for drag-and-drop will raise a protocol error.
	SetActions(dndActions DataDeviceManagerDndAction)
}

// The wl_data_source object is the source side of a wl_data_offer.
// It is created by the source client in a data transfer and
// provides a way to describe the offered data and a way to respond
// to requests to transfer the data.
type DataSource struct {
	// Listener's methods are called by incoming messages from the
	// remote end via Dispatch. If it is nil, messages are silently
	// ignored.
	Listener DataSourceListener

	// OnDelete is called when the object is removed from the tracking
	// system.
	OnDelete func()

	state wire.State
	id    uint32
}

// NewDataSource returns a newly instantiated DataSource. It is
// primarily intended for use by generated code.
func NewDataSource(state wire.State) *DataSource {
	return &DataSource{state: state}
}

func (obj *DataSource) State() wire.State {
	return obj.state
}

func (obj *DataSource) Dispatch(msg *wire.MessageBuffer) error {
	switch msg.Op() {
	case 0:

		mimeType := msg.ReadString()

		if err := msg.Err(); err != nil {
			return err
		}

		if obj.Listener == nil {
			return nil
		}
		obj.Listener.Offer(
			mimeType,
		)
		return nil

	case 1:
		if err := msg.Err(); err != nil {
			return err
		}

		if obj.Listener == nil {
			return nil
		}
		obj.Listener.Destroy()
		return nil

	case 2:

		dndActions := DataDeviceManagerDndAction(msg.ReadUint())

		if err := msg.Err(); err != nil {
			return err
		}

		if obj.Listener == nil {
			return nil
		}
		obj.Listener.SetActions(
			dndActions,
		)
		return nil
	}

	return wire.UnknownOpError{
		Interface: "wl_data_source",
		Type:      "request",
		Op:        msg.Op(),
	}
}

func (obj *DataSource) ID() uint32 {
	return obj.id
}

func (obj *DataSource) SetID(id uint32) {
	obj.id = id
}

func (obj *DataSource) Delete() {
	if obj.OnDelete != nil {
		obj.OnDelete()
	}
}

func (obj *DataSource) String() string {
	return fmt.Sprintf("%v(%v)", "wl_data_source", obj.id)
}

func (obj *DataSource) MethodName(op uint16) string {
	switch op {
	case 0:
		return "offer"

	case 1:
		return "destroy"

	case 2:
		return "set_actions"
	}

	return "unknown method"
}

func (obj *DataSource) Interface() string {
	return DataSourceInterface
}

func (obj *DataSource) Version() uint32 {
	return DataSourceVersion
}

// Sent when a target accepts pointer_focus or motion events.  If
// a target does not accept any of the offered types, type is NULL.
//
// Used for feedback during drag-and-drop.
func (obj *DataSource) Target(mimeType string) {
	builder := wire.NewMessage(obj, 0)
	builder.Method = "target"
	builder.Args = []any{mimeType}

	builder.WriteString(mimeType)

	obj.state.Enqueue(builder)
	return
}

// Request for data from the client.  Send the data as the
// specified mime type over the passed file descriptor, then
// close it.
func (obj *DataSource) Send(mimeType string, fd *os.File) {
	builder := wire.NewMessage(obj, 1)
	builder.Method = "send"
	builder.Args = []any{mimeType, fd}

	builder.WriteString(mimeType)
	builder.WriteFile(fd)

	obj.state.Enqueue(builder)
	return
}

// This data source is no longer valid. There are several reasons why
// this could happen:
//
// - The data source has been replaced by another data source.
// - The drag-and-drop operation was performed, but the drop destination
// did not accept any of the mime types offered through
// wl_data_source.target.
// - The drag-and-drop operation was performed, but the drop destination
// did not select any of the actions present in the mask offered through
// wl_data_source.action.
// - The drag-and-drop operation was performed but didn't happen over a
// surface.
// - The compositor cancelled the drag-and-drop operation (e.g. compositor
// dependent timeouts to avoid stale drag-and-drop transfers).
//
// The client should clean up and destroy this data source.
//
// For objects of version 2 or older, wl_data_source.cancelled will
// only be emitted if the data source was replaced by another data
// source.
func (obj *DataSource) Cancelled() {
	builder := wire.NewMessage(obj, 2)
	builder.Method = "cancelled"
	builder.Args = []any{}

	obj.state.Enqueue(builder)
	return
}

// The user performed the drop action. This event does not indicate
// acceptance, wl_data_source.cancelled may still be emitted afterwards
// if the drop destination does not accept any mime type.
//
// However, this event might however not be received if the compositor
// cancelled the drag-and-drop operation before this event could happen.
//
// Note that the data_source may still be used in the future and should
// not be destroyed here.
func (obj *DataSource) DndDropPerformed() {
	builder := wire.NewMessage(obj, 3)
	builder.Method = "dnd_drop_performed"
	builder.Args = []any{}

	obj.state.Enqueue(builder)
	return
}

// The drop destination finished interoperating with this data
// source, so the client is now free to destroy this data source and
// free all associated data.
//
// If the action used to perform the operation was "move", the
// source can now delete the transferred data.
func (obj *DataSource) DndFinished() {
	builder := wire.NewMessage(obj, 4)
	builder.Method = "dnd_finished"
	builder.Args = []any{}

	obj.state.Enqueue(builder)
	return
}

// This event indicates the action selected by the compositor after
// matching the source/destination side actions. Only one action (or
// none) will be offered here.
//
// This event can be emitted multiple times during the drag-and-drop
// operation, mainly in response to destination side changes through
// wl_data_offer.set_actions, and as the data device enters/leaves
// surfaces.
//
// It is only possible to receive this event after
// wl_data_source.dnd_drop_performed if the drag-and-drop operation
// ended in an "ask" action, in which case the final wl_data_source.action
// event will happen immediately before wl_data_source.dnd_finished.
//
// Compositors may also change the selected action on the fly, mainly
// in response to keyboard modifier changes during the drag-and-drop
// operation.
//
// The most recent action received is always the valid one. The chosen
// action may change alongside negotiation (e.g. an "ask" action can turn
// into a "move" operation), so the effects of the final action must
// always be applied in wl_data_offer.dnd_finished.
//
// Clients can trigger cursor surface changes from this point, so
// they reflect the current action.
func (obj *DataSource) Action(dndAction DataDeviceManagerDndAction) {
	builder := wire.NewMessage(obj, 5)
	builder.Method = "action"
	builder.Args = []any{dndAction}

	builder.WriteUint(uint32(dndAction))

	obj.state.Enqueue(builder)
	return
}

type DataSourceError int64

const (
	// action mask contains invalid values
	DataSourceErrorInvalidActionMask DataSourceError = 0

	// source doesn't accept this request
	DataSourceErrorInvalidSource DataSourceError = 1
)

func (enum DataSourceError) String() string {
	switch enum {
	case 0:
		return "DataSourceErrorInvalidActionMask"

	case 1:
		return "DataSourceErrorInvalidSource"
	}

	return "<invalid DataSourceError>"
}

const (
	DataDeviceInterface = "wl_data_device"
	DataDeviceVersion   = 3
)

// DataDeviceListener is a type that can respond to incoming
// messages for a DataDevice object.
type DataDeviceListener interface {
	// This request asks the compositor to start a drag-and-drop
	// operation on behalf of the client.
	//
	// The source argument is the data source that provides the data
	// for the eventual data transfer. If source is NULL, enter, leave
	// and motion events are sent only to the client that initiated the
	// drag and the client is expected to handle the data passing
	// internally. If source is destroyed, the drag-and-drop session will be
	// cancelled.
	//
	// The origin surface is the surface where the drag originates and
	// the client must have an active implicit grab that matches the
	// serial.
	//
	// The icon surface is an optional (can be NULL) surface that
	// provides an icon to be moved around with the cursor.  Initially,
	// the top-left corner of the icon surface is placed at the cursor
	// hotspot, but subsequent wl_surface.attach request can move the
	// relative position. Attach requests must be confirmed with
	// wl_surface.commit as usual. The icon surface is given the role of
	// a drag-and-drop icon. If the icon surface already has another role,
	// it raises a protocol error.
	//
	// The current and pending input regions of the icon wl_surface are
	// cleared, and wl_surface.set_input_region is ignored until the
	// wl_surface is no longer used as the icon surface. When the use
	// as an icon ends, the current and pending input regions become
	// undefined, and the wl_surface is unmapped.
	StartDrag(source *DataSource, origin *Surface, icon *Surface, serial uint32)

	// This request asks the compositor to set the selection
	// to the data from the source on behalf of the client.
	//
	// To unset the selection, set the source to NULL.
	SetSelection(source *DataSource, serial uint32)

	// This request destroys the data device.
	Release()
}

// There is one wl_data_device per seat which can be obtained
// from the global wl_data_device_manager singleton.
//
// A wl_data_device provides access to inter-client data transfer
// mechanisms such as copy-and-paste and drag-and-drop.
type DataDevice struct {
	// Listener's methods are called by incoming messages from the
	// remote end via Dispatch. If it is nil, messages are silently
	// ignored.
	Listener DataDeviceListener

	// OnDelete is called when the object is removed from the tracking
	// system.
	OnDelete func()

	state wire.State
	id    uint32
}

// NewDataDevice returns a newly instantiated DataDevice. It is
// primarily intended for use by generated code.
func NewDataDevice(state wire.State) *DataDevice {
	return &DataDevice{state: state}
}

func (obj *DataDevice) State() wire.State {
	return obj.state
}

func (obj *DataDevice) Dispatch(msg *wire.MessageBuffer) error {
	switch msg.Op() {
	case 0:
		source := NewDataSource(obj.state)
		source.SetID(msg.ReadUint())
		obj.state.Add(source)

		origin := NewSurface(obj.state)
		origin.SetID(msg.ReadUint())
		obj.state.Add(origin)

		icon := NewSurface(obj.state)
		icon.SetID(msg.ReadUint())
		obj.state.Add(icon)

		serial := msg.ReadUint()

		if err := msg.Err(); err != nil {
			return err
		}

		if obj.Listener == nil {
			return nil
		}
		obj.Listener.StartDrag(
			source,
			origin,
			icon,
			serial,
		)
		return nil

	case 1:
		source := NewDataSource(obj.state)
		source.SetID(msg.ReadUint())
		obj.state.Add(source)

		serial := msg.ReadUint()

		if err := msg.Err(); err != nil {
			return err
		}

		if obj.Listener == nil {
			return nil
		}
		obj.Listener.SetSelection(
			source,
			serial,
		)
		return nil

	case 2:
		if err := msg.Err(); err != nil {
			return err
		}

		if obj.Listener == nil {
			return nil
		}
		obj.Listener.Release()
		return nil
	}

	return wire.UnknownOpError{
		Interface: "wl_data_device",
		Type:      "request",
		Op:        msg.Op(),
	}
}

func (obj *DataDevice) ID() uint32 {
	return obj.id
}

func (obj *DataDevice) SetID(id uint32) {
	obj.id = id
}

func (obj *DataDevice) Delete() {
	if obj.OnDelete != nil {
		obj.OnDelete()
	}
}

func (obj *DataDevice) String() string {
	return fmt.Sprintf("%v(%v)", "wl_data_device", obj.id)
}

func (obj *DataDevice) MethodName(op uint16) string {
	switch op {
	case 0:
		return "start_drag"

	case 1:
		return "set_selection"

	case 2:
		return "release"
	}

	return "unknown method"
}

func (obj *DataDevice) Interface() string {
	return DataDeviceInterface
}

func (obj *DataDevice) Version() uint32 {
	return DataDeviceVersion
}

// The data_offer event introduces a new wl_data_offer object,
// which will subsequently be used in either the
// data_device.enter event (for drag-and-drop) or the
// data_device.selection event (for selections).  Immediately
// following the data_device_data_offer event, the new data_offer
// object will send out data_offer.offer events to describe the
// mime types it offers.
func (obj *DataDevice) DataOffer() (id *DataOffer) {
	builder := wire.NewMessage(obj, 0)
	builder.Method = "data_offer"
	builder.Args = []any{id}

	id = NewDataOffer(obj.state)
	obj.state.Add(id)
	builder.WriteObject(id)

	obj.state.Enqueue(builder)
	return id
}

// This event is sent when an active drag-and-drop pointer enters
// a surface owned by the client.  The position of the pointer at
// enter time is provided by the x and y arguments, in surface-local
// coordinates.
func (obj *DataDevice) Enter(serial uint32, surface *Surface, x wire.Fixed, y wire.Fixed, id *DataOffer) {
	builder := wire.NewMessage(obj, 1)
	builder.Method = "enter"
	builder.Args = []any{serial, surface, x, y, id}

	builder.WriteUint(serial)
	builder.WriteObject(surface)
	builder.WriteFixed(x)
	builder.WriteFixed(y)
	builder.WriteObject(id)

	obj.state.Enqueue(builder)
	return
}

// This event is sent when the drag-and-drop pointer leaves the
// surface and the session ends.  The client must destroy the
// wl_data_offer introduced at enter time at this point.
func (obj *DataDevice) Leave() {
	builder := wire.NewMessage(obj, 2)
	builder.Method = "leave"
	builder.Args = []any{}

	obj.state.Enqueue(builder)
	return
}

// This event is sent when the drag-and-drop pointer moves within
// the currently focused surface. The new position of the pointer
// is provided by the x and y arguments, in surface-local
// coordinates.
func (obj *DataDevice) Motion(time uint32, x wire.Fixed, y wire.Fixed) {
	builder := wire.NewMessage(obj, 3)
	builder.Method = "motion"
	builder.Args = []any{time, x, y}

	builder.WriteUint(time)
	builder.WriteFixed(x)
	builder.WriteFixed(y)

	obj.state.Enqueue(builder)
	return
}

// The event is sent when a drag-and-drop operation is ended
// because the implicit grab is removed.
//
// The drag-and-drop destination is expected to honor the last action
// received through wl_data_offer.action, if the resulting action is
// "copy" or "move", the destination can still perform
// wl_data_offer.receive requests, and is expected to end all
// transfers with a wl_data_offer.finish request.
//
// If the resulting action is "ask", the action will not be considered
// final. The drag-and-drop destination is expected to perform one last
// wl_data_offer.set_actions request, or wl_data_offer.destroy in order
// to cancel the operation.
func (obj *DataDevice) Drop() {
	builder := wire.NewMessage(obj, 4)
	builder.Method = "drop"
	builder.Args = []any{}

	obj.state.Enqueue(builder)
	return
}

// The selection event is sent out to notify the client of a new
// wl_data_offer for the selection for this device.  The
// data_device.data_offer and the data_offer.offer events are
// sent out immediately before this event to introduce the data
// offer object.  The selection event is sent to a client
// immediately before receiving keyboard focus and when a new
// selection is set while the client has keyboard focus.  The
// data_offer is valid until a new data_offer or NULL is received
// or until the client loses keyboard focus.  The client must
// destroy the previous selection data_offer, if any, upon receiving
// this event.
func (obj *DataDevice) Selection(id *DataOffer) {
	builder := wire.NewMessage(obj, 5)
	builder.Method = "selection"
	builder.Args = []any{id}

	builder.WriteObject(id)

	obj.state.Enqueue(builder)
	return
}

type DataDeviceError int64

const (
	// given wl_surface has another role
	DataDeviceErrorRole DataDeviceError = 0
)

func (enum DataDeviceError) String() string {
	switch enum {
	case 0:
		return "DataDeviceErrorRole"
	}

	return "<invalid DataDeviceError>"
}

const (
	DataDeviceManagerInterface = "wl_data_device_manager"
	DataDeviceManagerVersion   = 3
)

// DataDeviceManagerListener is a type that can respond to incoming
// messages for a DataDeviceManager object.
type DataDeviceManagerListener interface {
	// Create a new data source.
	CreateDataSource(id *DataSource)

	// Create a new data device for a given seat.
	GetDataDevice(id *DataDevice, seat *Seat)
}

// The wl_data_device_manager is a singleton global object that
// provides access to inter-client data transfer mechanisms such as
// copy-and-paste and drag-and-drop.  These mechanisms are tied to
// a wl_seat and this interface lets a client get a wl_data_device
// corresponding to a wl_seat.
//
// Depending on the version bound, the objects created from the bound
// wl_data_device_manager object will have different requirements for
// functioning properly. See wl_data_source.set_actions,
// wl_data_offer.accept and wl_data_offer.finish for details.
type DataDeviceManager struct {
	// Listener's methods are called by incoming messages from the
	// remote end via Dispatch. If it is nil, messages are silently
	// ignored.
	Listener DataDeviceManagerListener

	// OnDelete is called when the object is removed from the tracking
	// system.
	OnDelete func()

	state wire.State
	id    uint32
}

// NewDataDeviceManager returns a newly instantiated DataDeviceManager. It is
// primarily intended for use by generated code.
func NewDataDeviceManager(state wire.State) *DataDeviceManager {
	return &DataDeviceManager{state: state}
}

func BindDataDeviceManager(state wire.State, id wire.NewID) *DataDeviceManager {
	obj := NewDataDeviceManager(state)
	obj.SetID(id.ID)
	state.Add(obj)
	return obj
}

func (obj *DataDeviceManager) State() wire.State {
	return obj.state
}

func (obj *DataDeviceManager) Dispatch(msg *wire.MessageBuffer) error {
	switch msg.Op() {
	case 0:
		id := NewDataSource(obj.state)
		id.SetID(msg.ReadUint())
		obj.state.Add(id)

		if err := msg.Err(); err != nil {
			return err
		}

		if obj.Listener == nil {
			return nil
		}
		obj.Listener.CreateDataSource(
			id,
		)
		return nil

	case 1:
		id := NewDataDevice(obj.state)
		id.SetID(msg.ReadUint())
		obj.state.Add(id)

		seat := NewSeat(obj.state)
		seat.SetID(msg.ReadUint())
		obj.state.Add(seat)

		if err := msg.Err(); err != nil {
			return err
		}

		if obj.Listener == nil {
			return nil
		}
		obj.Listener.GetDataDevice(
			id,
			seat,
		)
		return nil
	}

	return wire.UnknownOpError{
		Interface: "wl_data_device_manager",
		Type:      "request",
		Op:        msg.Op(),
	}
}

func (obj *DataDeviceManager) ID() uint32 {
	return obj.id
}

func (obj *DataDeviceManager) SetID(id uint32) {
	obj.id = id
}

func (obj *DataDeviceManager) Delete() {
	if obj.OnDelete != nil {
		obj.OnDelete()
	}
}

func (obj *DataDeviceManager) String() string {
	return fmt.Sprintf("%v(%v)", "wl_data_device_manager", obj.id)
}

func (obj *DataDeviceManager) MethodName(op uint16) string {
	switch op {
	case 0:
		return "create_data_source"

	case 1:
		return "get_data_device"
	}

	return "unknown method"
}

func (obj *DataDeviceManager) Interface() string {
	return DataDeviceManagerInterface
}

func (obj *DataDeviceManager) Version() uint32 {
	return DataDeviceManagerVersion
}

// This is a bitmask of the available/preferred actions in a
// drag-and-drop operation.
//
// In the compositor, the selected action is a result of matching the
// actions offered by the source and destination sides.  "action" events
// with a "none" action will be sent to both source and destination if
// there is no match. All further checks will effectively happen on
// (source actions  destination actions).
//
// In addition, compositors may also pick different actions in
// reaction to key modifiers being pressed. One common design that
// is used in major toolkits (and the behavior recommended for
// compositors) is:
//
// - If no modifiers are pressed, the first match (in bit order)
// will be used.
// - Pressing Shift selects "move", if enabled in the mask.
// - Pressing Control selects "copy", if enabled in the mask.
//
// Behavior beyond that is considered implementation-dependent.
// Compositors may for example bind other modifiers (like Alt/Meta)
// or drags initiated with other buttons than BTN_LEFT to specific
// actions (e.g. "ask").
type DataDeviceManagerDndAction int64

const (
	// no action
	DataDeviceManagerDndActionNone DataDeviceManagerDndAction = 0

	// copy action
	DataDeviceManagerDndActionCopy DataDeviceManagerDndAction = 1

	// move action
	DataDeviceManagerDndActionMove DataDeviceManagerDndAction = 2

	// ask action
	DataDeviceManagerDndActionAsk DataDeviceManagerDndAction = 4
)

func (enum DataDeviceManagerDndAction) String() string {
	switch enum {
	case 0:
		return "DataDeviceManagerDndActionNone"

	case 1:
		return "DataDeviceManagerDndActionCopy"

	case 2:
		return "DataDeviceManagerDndActionMove"

	case 4:
		return "DataDeviceManagerDndActionAsk"
	}

	return "<invalid DataDeviceManagerDndAction>"
}

const (
	ShellInterface = "wl_shell"
	ShellVersion   = 1
)

// ShellListener is a type that can respond to incoming
// messages for a Shell object.
type ShellListener interface {
	// Create a shell surface for an existing surface. This gives
	// the wl_surface the role of a shell surface. If the wl_surface
	// already has another role, it raises a protocol error.
	//
	// Only one shell surface can be associated with a given surface.
	GetShellSurface(id *ShellSurface, surface *Surface)
}

// This interface is implemented by servers that provide
// desktop-style user interfaces.
//
// It allows clients to associate a wl_shell_surface with
// a basic surface.
//
// Note! This protocol is deprecated and not intended for production use.
// For desktop-style user interfaces, use xdg_shell.
type Shell struct {
	// Listener's methods are called by incoming messages from the
	// remote end via Dispatch. If it is nil, messages are silently
	// ignored.
	Listener ShellListener

	// OnDelete is called when the object is removed from the tracking
	// system.
	OnDelete func()

	state wire.State
	id    uint32
}

// NewShell returns a newly instantiated Shell. It is
// primarily intended for use by generated code.
func NewShell(state wire.State) *Shell {
	return &Shell{state: state}
}

func BindShell(state wire.State, id wire.NewID) *Shell {
	obj := NewShell(state)
	obj.SetID(id.ID)
	state.Add(obj)
	return obj
}

func (obj *Shell) State() wire.State {
	return obj.state
}

func (obj *Shell) Dispatch(msg *wire.MessageBuffer) error {
	switch msg.Op() {
	case 0:
		id := NewShellSurface(obj.state)
		id.SetID(msg.ReadUint())
		obj.state.Add(id)

		surface := NewSurface(obj.state)
		surface.SetID(msg.ReadUint())
		obj.state.Add(surface)

		if err := msg.Err(); err != nil {
			return err
		}

		if obj.Listener == nil {
			return nil
		}
		obj.Listener.GetShellSurface(
			id,
			surface,
		)
		return nil
	}

	return wire.UnknownOpError{
		Interface: "wl_shell",
		Type:      "request",
		Op:        msg.Op(),
	}
}

func (obj *Shell) ID() uint32 {
	return obj.id
}

func (obj *Shell) SetID(id uint32) {
	obj.id = id
}

func (obj *Shell) Delete() {
	if obj.OnDelete != nil {
		obj.OnDelete()
	}
}

func (obj *Shell) String() string {
	return fmt.Sprintf("%v(%v)", "wl_shell", obj.id)
}

func (obj *Shell) MethodName(op uint16) string {
	switch op {
	case 0:
		return "get_shell_surface"
	}

	return "unknown method"
}

func (obj *Shell) Interface() string {
	return ShellInterface
}

func (obj *Shell) Version() uint32 {
	return ShellVersion
}

type ShellError int64

const (
	// given wl_surface has another role
	ShellErrorRole ShellError = 0
)

func (enum ShellError) String() string {
	switch enum {
	case 0:
		return "ShellErrorRole"
	}

	return "<invalid ShellError>"
}

const (
	ShellSurfaceInterface = "wl_shell_surface"
	ShellSurfaceVersion   = 1
)

// ShellSurfaceListener is a type that can respond to incoming
// messages for a ShellSurface object.
type ShellSurfaceListener interface {
	// A client must respond to a ping event with a pong request or
	// the client may be deemed unresponsive.
	Pong(serial uint32)

	// Start a pointer-driven move of the surface.
	//
	// This request must be used in response to a button press event.
	// The server may ignore move requests depending on the state of
	// the surface (e.g. fullscreen or maximized).
	Move(seat *Seat, serial uint32)

	// Start a pointer-driven resizing of the surface.
	//
	// This request must be used in response to a button press event.
	// The server may ignore resize requests depending on the state of
	// the surface (e.g. fullscreen or maximized).
	Resize(seat *Seat, serial uint32, edges ShellSurfaceResize)

	// Map the surface as a toplevel surface.
	//
	// A toplevel surface is not fullscreen, maximized or transient.
	SetToplevel()

	// Map the surface relative to an existing surface.
	//
	// The x and y arguments specify the location of the upper left
	// corner of the surface relative to the upper left corner of the
	// parent surface, in surface-local coordinates.
	//
	// The flags argument controls details of the transient behaviour.
	SetTransient(parent *Surface, x int32, y int32, flags ShellSurfaceTransient)

	// Map the surface as a fullscreen surface.
	//
	// If an output parameter is given then the surface will be made
	// fullscreen on that output. If the client does not specify the
	// output then the compositor will apply its policy - usually
	// choosing the output on which the surface has the biggest surface
	// area.
	//
	// The client may specify a method to resolve a size conflict
	// between the output size and the surface size - this is provided
	// through the method parameter.
	//
	// The framerate parameter is used only when the method is set
	// to "driver", to indicate the preferred framerate. A value of 0
	// indicates that the client does not care about framerate.  The
	// framerate is specified in mHz, that is framerate of 60000 is 60Hz.
	//
	// A method of "scale" or "driver" implies a scaling operation of
	// the surface, either via a direct scaling operation or a change of
	// the output mode. This will override any kind of output scaling, so
	// that mapping a surface with a buffer size equal to the mode can
	// fill the screen independent of buffer_scale.
	//
	// A method of "fill" means we don't scale up the buffer, however
	// any output scale is applied. This means that you may run into
	// an edge case where the application maps a buffer with the same
	// size of the output mode but buffer_scale 1 (thus making a
	// surface larger than the output). In this case it is allowed to
	// downscale the results to fit the screen.
	//
	// The compositor must reply to this request with a configure event
	// with the dimensions for the output on which the surface will
	// be made fullscreen.
	SetFullscreen(method ShellSurfaceFullscreenMethod, framerate uint32, output *Output)

	// Map the surface as a popup.
	//
	// A popup surface is a transient surface with an added pointer
	// grab.
	//
	// An existing implicit grab will be changed to owner-events mode,
	// and the popup grab will continue after the implicit grab ends
	// (i.e. releasing the mouse button does not cause the popup to
	// be unmapped).
	//
	// The popup grab continues until the window is destroyed or a
	// mouse button is pressed in any other client's window. A click
	// in any of the client's surfaces is reported as normal, however,
	// clicks in other clients' surfaces will be discarded and trigger
	// the callback.
	//
	// The x and y arguments specify the location of the upper left
	// corner of the surface relative to the upper left corner of the
	// parent surface, in surface-local coordinates.
	SetPopup(seat *Seat, serial uint32, parent *Surface, x int32, y int32, flags ShellSurfaceTransient)

	// Map the surface as a maximized surface.
	//
	// If an output parameter is given then the surface will be
	// maximized on that output. If the client does not specify the
	// output then the compositor will apply its policy - usually
	// choosing the output on which the surface has the biggest surface
	// area.
	//
	// The compositor will reply with a configure event telling
	// the expected new surface size. The operation is completed
	// on the next buffer attach to this surface.
	//
	// A maximized surface typically fills the entire output it is
	// bound to, except for desktop elements such as panels. This is
	// the main difference between a maximized shell surface and a
	// fullscreen shell surface.
	//
	// The details depend on the compositor implementation.
	SetMaximized(output *Output)

	// Set a short title for the surface.
	//
	// This string may be used to identify the surface in a task bar,
	// window list, or other user interface elements provided by the
	// compositor.
	//
	// The string must be encoded in UTF-8.
	SetTitle(title string)

	// Set a class for the surface.
	//
	// The surface class identifies the general class of applications
	// to which the surface belongs. A common convention is to use the
	// file name (or the full path if it is a non-standard location) of
	// the application's .desktop file as the class.
	SetClass(class string)
}

// An interface that may be implemented by a wl_surface, for
// implementations that provide a desktop-style user interface.
//
// It provides requests to treat surfaces like toplevel, fullscreen
// or popup windows, move, resize or maximize them, associate
// metadata like title and class, etc.
//
// On the server side the object is automatically destroyed when
// the related wl_surface is destroyed. On the client side,
// wl_shell_surface_destroy() must be called before destroying
// the wl_surface object.
type ShellSurface struct {
	// Listener's methods are called by incoming messages from the
	// remote end via Dispatch. If it is nil, messages are silently
	// ignored.
	Listener ShellSurfaceListener

	// OnDelete is called when the object is removed from the tracking
	// system.
	OnDelete func()

	state wire.State
	id    uint32
}

// NewShellSurface returns a newly instantiated ShellSurface. It is
// primarily intended for use by generated code.
func NewShellSurface(state wire.State) *ShellSurface {
	return &ShellSurface{state: state}
}

func (obj *ShellSurface) State() wire.State {
	return obj.state
}

func (obj *ShellSurface) Dispatch(msg *wire.MessageBuffer) error {
	switch msg.Op() {
	case 0:

		serial := msg.ReadUint()

		if err := msg.Err(); err != nil {
			return err
		}

		if obj.Listener == nil {
			return nil
		}
		obj.Listener.Pong(
			serial,
		)
		return nil

	case 1:
		seat := NewSeat(obj.state)
		seat.SetID(msg.ReadUint())
		obj.state.Add(seat)

		serial := msg.ReadUint()

		if err := msg.Err(); err != nil {
			return err
		}

		if obj.Listener == nil {
			return nil
		}
		obj.Listener.Move(
			seat,
			serial,
		)
		return nil

	case 2:
		seat := NewSeat(obj.state)
		seat.SetID(msg.ReadUint())
		obj.state.Add(seat)

		serial := msg.ReadUint()

		edges := ShellSurfaceResize(msg.ReadUint())

		if err := msg.Err(); err != nil {
			return err
		}

		if obj.Listener == nil {
			return nil
		}
		obj.Listener.Resize(
			seat,
			serial,
			edges,
		)
		return nil

	case 3:
		if err := msg.Err(); err != nil {
			return err
		}

		if obj.Listener == nil {
			return nil
		}
		obj.Listener.SetToplevel()
		return nil

	case 4:
		parent := NewSurface(obj.state)
		parent.SetID(msg.ReadUint())
		obj.state.Add(parent)

		x := msg.ReadInt()

		y := msg.ReadInt()

		flags := ShellSurfaceTransient(msg.ReadUint())

		if err := msg.Err(); err != nil {
			return err
		}

		if obj.Listener == nil {
			return nil
		}
		obj.Listener.SetTransient(
			parent,
			x,
			y,
			flags,
		)
		return nil

	case 5:

		method := ShellSurfaceFullscreenMethod(msg.ReadUint())

		framerate := msg.ReadUint()

		output := NewOutput(obj.state)
		output.SetID(msg.ReadUint())
		obj.state.Add(output)

		if err := msg.Err(); err != nil {
			return err
		}

		if obj.Listener == nil {
			return nil
		}
		obj.Listener.SetFullscreen(
			method,
			framerate,
			output,
		)
		return nil

	case 6:
		seat := NewSeat(obj.state)
		seat.SetID(msg.ReadUint())
		obj.state.Add(seat)

		serial := msg.ReadUint()

		parent := NewSurface(obj.state)
		parent.SetID(msg.ReadUint())
		obj.state.Add(parent)

		x := msg.ReadInt()

		y := msg.ReadInt()

		flags := ShellSurfaceTransient(msg.ReadUint())

		if err := msg.Err(); err != nil {
			return err
		}

		if obj.Listener == nil {
			return nil
		}
		obj.Listener.SetPopup(
			seat,
			serial,
			parent,
			x,
			y,
			flags,
		)
		return nil

	case 7:
		output := NewOutput(obj.state)
		output.SetID(msg.ReadUint())
		obj.state.Add(output)

		if err := msg.Err(); err != nil {
			return err
		}

		if obj.Listener == nil {
			return nil
		}
		obj.Listener.SetMaximized(
			output,
		)
		return nil

	case 8:

		title := msg.ReadString()

		if err := msg.Err(); err != nil {
			return err
		}

		if obj.Listener == nil {
			return nil
		}
		obj.Listener.SetTitle(
			title,
		)
		return nil

	case 9:

		class := msg.ReadString()

		if err := msg.Err(); err != nil {
			return err
		}

		if obj.Listener == nil {
			return nil
		}
		obj.Listener.SetClass(
			class,
		)
		return nil
	}

	return wire.UnknownOpError{
		Interface: "wl_shell_surface",
		Type:      "request",
		Op:        msg.Op(),
	}
}

func (obj *ShellSurface) ID() uint32 {
	return obj.id
}

func (obj *ShellSurface) SetID(id uint32) {
	obj.id = id
}

func (obj *ShellSurface) Delete() {
	if obj.OnDelete != nil {
		obj.OnDelete()
	}
}

func (obj *ShellSurface) String() string {
	return fmt.Sprintf("%v(%v)", "wl_shell_surface", obj.id)
}

func (obj *ShellSurface) MethodName(op uint16) string {
	switch op {
	case 0:
		return "pong"

	case 1:
		return "move"

	case 2:
		return "resize"

	case 3:
		return "set_toplevel"

	case 4:
		return "set_transient"

	case 5:
		return "set_fullscreen"

	case 6:
		return "set_popup"

	case 7:
		return "set_maximized"

	case 8:
		return "set_title"

	case 9:
		return "set_class"
	}

	return "unknown method"
}

func (obj *ShellSurface) Interface() string {
	return ShellSurfaceInterface
}

func (obj *ShellSurface) Version() uint32 {
	return ShellSurfaceVersion
}

// Ping a client to check if it is receiving events and sending
// requests. A client is expected to reply with a pong request.
func (obj *ShellSurface) Ping(serial uint32) {
	builder := wire.NewMessage(obj, 0)
	builder.Method = "ping"
	builder.Args = []any{serial}

	builder.WriteUint(serial)

	obj.state.Enqueue(builder)
	return
}

// The configure event asks the client to resize its surface.
//
// The size is a hint, in the sense that the client is free to
// ignore it if it doesn't resize, pick a smaller size (to
// satisfy aspect ratio or resize in steps of NxM pixels).
//
// The edges parameter provides a hint about how the surface
// was resized. The client may use this information to decide
// how to adjust its content to the new size (e.g. a scrolling
// area might adjust its content position to leave the viewable
// content unmoved).
//
// The client is free to dismiss all but the last configure
// event it received.
//
// The width and height arguments specify the size of the window
// in surface-local coordinates.
func (obj *ShellSurface) Configure(edges ShellSurfaceResize, width int32, height int32) {
	builder := wire.NewMessage(obj, 1)
	builder.Method = "configure"
	builder.Args = []any{edges, width, height}

	builder.WriteUint(uint32(edges))
	builder.WriteInt(width)
	builder.WriteInt(height)

	obj.state.Enqueue(builder)
	return
}

// The popup_done event is sent out when a popup grab is broken,
// that is, when the user clicks a surface that doesn't belong
// to the client owning the popup surface.
func (obj *ShellSurface) PopupDone() {
	builder := wire.NewMessage(obj, 2)
	builder.Method = "popup_done"
	builder.Args = []any{}

	obj.state.Enqueue(builder)
	return
}

// These values are used to indicate which edge of a surface
// is being dragged in a resize operation. The server may
// use this information to adapt its behavior, e.g. choose
// an appropriate cursor image.
type ShellSurfaceResize int64

const (
	// no edge
	ShellSurfaceResizeNone ShellSurfaceResize = 0

	// top edge
	ShellSurfaceResizeTop ShellSurfaceResize = 1

	// bottom edge
	ShellSurfaceResizeBottom ShellSurfaceResize = 2

	// left edge
	ShellSurfaceResizeLeft ShellSurfaceResize = 4

	// top and left edges
	ShellSurfaceResizeTopLeft ShellSurfaceResize = 5

	// bottom and left edges
	ShellSurfaceResizeBottomLeft ShellSurfaceResize = 6

	// right edge
	ShellSurfaceResizeRight ShellSurfaceResize = 8

	// top and right edges
	ShellSurfaceResizeTopRight ShellSurfaceResize = 9

	// bottom and right edges
	ShellSurfaceResizeBottomRight ShellSurfaceResize = 10
)

func (enum ShellSurfaceResize) String() string {
	switch enum {
	case 0:
		return "ShellSurfaceResizeNone"

	case 1:
		return "ShellSurfaceResizeTop"

	case 2:
		return "ShellSurfaceResizeBottom"

	case 4:
		return "ShellSurfaceResizeLeft"

	case 5:
		return "ShellSurfaceResizeTopLeft"

	case 6:
		return "ShellSurfaceResizeBottomLeft"

	case 8:
		return "ShellSurfaceResizeRight"

	case 9:
		return "ShellSurfaceResizeTopRight"

	case 10:
		return "ShellSurfaceResizeBottomRight"
	}

	return "<invalid ShellSurfaceResize>"
}

// These flags specify details of the expected behaviour
// of transient surfaces. Used in the set_transient request.
type ShellSurfaceTransient int64

const (
	// do not set keyboard focus
	ShellSurfaceTransientInactive ShellSurfaceTransient = 1
)

func (enum ShellSurfaceTransient) String() string {
	switch enum {
	case 1:
		return "ShellSurfaceTransientInactive"
	}

	return "<invalid ShellSurfaceTransient>"
}

// Hints to indicate to the compositor how to deal with a conflict
// between the dimensions of the surface and the dimensions of the
// output. The compositor is free to ignore this parameter.
type ShellSurfaceFullscreenMethod int64

const (
	// no preference, apply default policy
	ShellSurfaceFullscreenMethodDefault ShellSurfaceFullscreenMethod = 0

	// scale, preserve the surface's aspect ratio and center on output
	ShellSurfaceFullscreenMethodScale ShellSurfaceFullscreenMethod = 1

	// switch output mode to the smallest mode that can fit the surface, add black borders to compensate size mismatch
	ShellSurfaceFullscreenMethodDriver ShellSurfaceFullscreenMethod = 2

	// no upscaling, center on output and add black borders to compensate size mismatch
	ShellSurfaceFullscreenMethodFill ShellSurfaceFullscreenMethod = 3
)

func (enum ShellSurfaceFullscreenMethod) String() string {
	switch enum {
	case 0:
		return "ShellSurfaceFullscreenMethodDefault"

	case 1:
		return "ShellSurfaceFullscreenMethodScale"

	case 2:
		return "ShellSurfaceFullscreenMethodDriver"

	case 3:
		return "ShellSurfaceFullscreenMethodFill"
	}

	return "<invalid ShellSurfaceFullscreenMethod>"
}

const (
	SurfaceInterface = "wl_surface"
	SurfaceVersion   = 4
)

// SurfaceListener is a type that can respond to incoming
// messages for a Surface object.
type SurfaceListener interface {
	// Deletes the surface and invalidates its object ID.
	Destroy()

	// Set a buffer as the content of this surface.
	//
	// The new size of the surface is calculated based on the buffer
	// size transformed by the inverse buffer_transform and the
	// inverse buffer_scale. This means that at commit time the supplied
	// buffer size must be an integer multiple of the buffer_scale. If
	// that's not the case, an invalid_size error is sent.
	//
	// The x and y arguments specify the location of the new pending
	// buffer's upper left corner, relative to the current buffer's upper
	// left corner, in surface-local coordinates. In other words, the
	// x and y, combined with the new surface size define in which
	// directions the surface's size changes.
	//
	// Surface contents are double-buffered state, see wl_surface.commit.
	//
	// The initial surface contents are void; there is no content.
	// wl_surface.attach assigns the given wl_buffer as the pending
	// wl_buffer. wl_surface.commit makes the pending wl_buffer the new
	// surface contents, and the size of the surface becomes the size
	// calculated from the wl_buffer, as described above. After commit,
	// there is no pending buffer until the next attach.
	//
	// Committing a pending wl_buffer allows the compositor to read the
	// pixels in the wl_buffer. The compositor may access the pixels at
	// any time after the wl_surface.commit request. When the compositor
	// will not access the pixels anymore, it will send the
	// wl_buffer.release event. Only after receiving wl_buffer.release,
	// the client may reuse the wl_buffer. A wl_buffer that has been
	// attached and then replaced by another attach instead of committed
	// will not receive a release event, and is not used by the
	// compositor.
	//
	// If a pending wl_buffer has been committed to more than one wl_surface,
	// the delivery of wl_buffer.release events becomes undefined. A well
	// behaved client should not rely on wl_buffer.release events in this
	// case. Alternatively, a client could create multiple wl_buffer objects
	// from the same backing storage or use wp_linux_buffer_release.
	//
	// Destroying the wl_buffer after wl_buffer.release does not change
	// the surface contents. However, if the client destroys the
	// wl_buffer before receiving the wl_buffer.release event, the surface
	// contents become undefined immediately.
	//
	// If wl_surface.attach is sent with a NULL wl_buffer, the
	// following wl_surface.commit will remove the surface content.
	Attach(buffer *Buffer, x int32, y int32)

	// This request is used to describe the regions where the pending
	// buffer is different from the current surface contents, and where
	// the surface therefore needs to be repainted. The compositor
	// ignores the parts of the damage that fall outside of the surface.
	//
	// Damage is double-buffered state, see wl_surface.commit.
	//
	// The damage rectangle is specified in surface-local coordinates,
	// where x and y specify the upper left corner of the damage rectangle.
	//
	// The initial value for pending damage is empty: no damage.
	// wl_surface.damage adds pending damage: the new pending damage
	// is the union of old pending damage and the given rectangle.
	//
	// wl_surface.commit assigns pending damage as the current damage,
	// and clears pending damage. The server will clear the current
	// damage as it repaints the surface.
	//
	// Note! New clients should not use this request. Instead damage can be
	// posted with wl_surface.damage_buffer which uses buffer coordinates
	// instead of surface coordinates.
	Damage(x int32, y int32, width int32, height int32)

	// Request a notification when it is a good time to start drawing a new
	// frame, by creating a frame callback. This is useful for throttling
	// redrawing operations, and driving animations.
	//
	// When a client is animating on a wl_surface, it can use the 'frame'
	// request to get notified when it is a good time to draw and commit the
	// next frame of animation. If the client commits an update earlier than
	// that, it is likely that some updates will not make it to the display,
	// and the client is wasting resources by drawing too often.
	//
	// The frame request will take effect on the next wl_surface.commit.
	// The notification will only be posted for one frame unless
	// requested again. For a wl_surface, the notifications are posted in
	// the order the frame requests were committed.
	//
	// The server must send the notifications so that a client
	// will not send excessive updates, while still allowing
	// the highest possible update rate for clients that wait for the reply
	// before drawing again. The server should give some time for the client
	// to draw and commit after sending the frame callback events to let it
	// hit the next output refresh.
	//
	// A server should avoid signaling the frame callbacks if the
	// surface is not visible in any way, e.g. the surface is off-screen,
	// or completely obscured by other opaque surfaces.
	//
	// The object returned by this request will be destroyed by the
	// compositor after the callback is fired and as such the client must not
	// attempt to use it after that point.
	//
	// The callback_data passed in the callback is the current time, in
	// milliseconds, with an undefined base.
	Frame(callback *Callback)

	// This request sets the region of the surface that contains
	// opaque content.
	//
	// The opaque region is an optimization hint for the compositor
	// that lets it optimize the redrawing of content behind opaque
	// regions.  Setting an opaque region is not required for correct
	// behaviour, but marking transparent content as opaque will result
	// in repaint artifacts.
	//
	// The opaque region is specified in surface-local coordinates.
	//
	// The compositor ignores the parts of the opaque region that fall
	// outside of the surface.
	//
	// Opaque region is double-buffered state, see wl_surface.commit.
	//
	// wl_surface.set_opaque_region changes the pending opaque region.
	// wl_surface.commit copies the pending region to the current region.
	// Otherwise, the pending and current regions are never changed.
	//
	// The initial value for an opaque region is empty. Setting the pending
	// opaque region has copy semantics, and the wl_region object can be
	// destroyed immediately. A NULL wl_region causes the pending opaque
	// region to be set to empty.
	SetOpaqueRegion(region *Region)

	// This request sets the region of the surface that can receive
	// pointer and touch events.
	//
	// Input events happening outside of this region will try the next
	// surface in the server surface stack. The compositor ignores the
	// parts of the input region that fall outside of the surface.
	//
	// The input region is specified in surface-local coordinates.
	//
	// Input region is double-buffered state, see wl_surface.commit.
	//
	// wl_surface.set_input_region changes the pending input region.
	// wl_surface.commit copies the pending region to the current region.
	// Otherwise the pending and current regions are never changed,
	// except cursor and icon surfaces are special cases, see
	// wl_pointer.set_cursor and wl_data_device.start_drag.
	//
	// The initial value for an input region is infinite. That means the
	// whole surface will accept input. Setting the pending input region
	// has copy semantics, and the wl_region object can be destroyed
	// immediately. A NULL wl_region causes the input region to be set
	// to infinite.
	SetInputRegion(region *Region)

	// Surface state (input, opaque, and damage regions, attached buffers,
	// etc.) is double-buffered. Protocol requests modify the pending state,
	// as opposed to the current state in use by the compositor. A commit
	// request atomically applies all pending state, replacing the current
	// state. After commit, the new pending state is as documented for each
	// related request.
	//
	// On commit, a pending wl_buffer is applied first, and all other state
	// second. This means that all coordinates in double-buffered state are
	// relative to the new wl_buffer coming into use, except for
	// wl_surface.attach itself. If there is no pending wl_buffer, the
	// coordinates are relative to the current surface contents.
	//
	// All requests that need a commit to become effective are documented
	// to affect double-buffered state.
	//
	// Other interfaces may add further double-buffered surface state.
	Commit()

	// This request sets an optional transformation on how the compositor
	// interprets the contents of the buffer attached to the surface. The
	// accepted values for the transform parameter are the values for
	// wl_output.transform.
	//
	// Buffer transform is double-buffered state, see wl_surface.commit.
	//
	// A newly created surface has its buffer transformation set to normal.
	//
	// wl_surface.set_buffer_transform changes the pending buffer
	// transformation. wl_surface.commit copies the pending buffer
	// transformation to the current one. Otherwise, the pending and current
	// values are never changed.
	//
	// The purpose of this request is to allow clients to render content
	// according to the output transform, thus permitting the compositor to
	// use certain optimizations even if the display is rotated. Using
	// hardware overlays and scanning out a client buffer for fullscreen
	// surfaces are examples of such optimizations. Those optimizations are
	// highly dependent on the compositor implementation, so the use of this
	// request should be considered on a case-by-case basis.
	//
	// Note that if the transform value includes 90 or 270 degree rotation,
	// the width of the buffer will become the surface height and the height
	// of the buffer will become the surface width.
	//
	// If transform is not one of the values from the
	// wl_output.transform enum the invalid_transform protocol error
	// is raised.
	SetBufferTransform(transform OutputTransform)

	// This request sets an optional scaling factor on how the compositor
	// interprets the contents of the buffer attached to the window.
	//
	// Buffer scale is double-buffered state, see wl_surface.commit.
	//
	// A newly created surface has its buffer scale set to 1.
	//
	// wl_surface.set_buffer_scale changes the pending buffer scale.
	// wl_surface.commit copies the pending buffer scale to the current one.
	// Otherwise, the pending and current values are never changed.
	//
	// The purpose of this request is to allow clients to supply higher
	// resolution buffer data for use on high resolution outputs. It is
	// intended that you pick the same buffer scale as the scale of the
	// output that the surface is displayed on. This means the compositor
	// can avoid scaling when rendering the surface on that output.
	//
	// Note that if the scale is larger than 1, then you have to attach
	// a buffer that is larger (by a factor of scale in each dimension)
	// than the desired surface size.
	//
	// If scale is not positive the invalid_scale protocol error is
	// raised.
	SetBufferScale(scale int32)

	// This request is used to describe the regions where the pending
	// buffer is different from the current surface contents, and where
	// the surface therefore needs to be repainted. The compositor
	// ignores the parts of the damage that fall outside of the surface.
	//
	// Damage is double-buffered state, see wl_surface.commit.
	//
	// The damage rectangle is specified in buffer coordinates,
	// where x and y specify the upper left corner of the damage rectangle.
	//
	// The initial value for pending damage is empty: no damage.
	// wl_surface.damage_buffer adds pending damage: the new pending
	// damage is the union of old pending damage and the given rectangle.
	//
	// wl_surface.commit assigns pending damage as the current damage,
	// and clears pending damage. The server will clear the current
	// damage as it repaints the surface.
	//
	// This request differs from wl_surface.damage in only one way - it
	// takes damage in buffer coordinates instead of surface-local
	// coordinates. While this generally is more intuitive than surface
	// coordinates, it is especially desirable when using wp_viewport
	// or when a drawing library (like EGL) is unaware of buffer scale
	// and buffer transform.
	//
	// Note: Because buffer transformation changes and damage requests may
	// be interleaved in the protocol stream, it is impossible to determine
	// the actual mapping between surface and buffer damage until
	// wl_surface.commit time. Therefore, compositors wishing to take both
	// kinds of damage into account will have to accumulate damage from the
	// two requests separately and only transform from one to the other
	// after receiving the wl_surface.commit.
	DamageBuffer(x int32, y int32, width int32, height int32)
}

// A surface is a rectangular area that may be displayed on zero
// or more outputs, and shown any number of times at the compositor's
// discretion. They can present wl_buffers, receive user input, and
// define a local coordinate system.
//
// The size of a surface (and relative positions on it) is described
// in surface-local coordinates, which may differ from the buffer
// coordinates of the pixel content, in case a buffer_transform
// or a buffer_scale is used.
//
// A surface without a "role" is fairly useless: a compositor does
// not know where, when or how to present it. The role is the
// purpose of a wl_surface. Examples of roles are a cursor for a
// pointer (as set by wl_pointer.set_cursor), a drag icon
// (wl_data_device.start_drag), a sub-surface
// (wl_subcompositor.get_subsurface), and a window as defined by a
// shell protocol (e.g. wl_shell.get_shell_surface).
//
// A surface can have only one role at a time. Initially a
// wl_surface does not have a role. Once a wl_surface is given a
// role, it is set permanently for the whole lifetime of the
// wl_surface object. Giving the current role again is allowed,
// unless explicitly forbidden by the relevant interface
// specification.
//
// Surface roles are given by requests in other interfaces such as
// wl_pointer.set_cursor. The request should explicitly mention
// that this request gives a role to a wl_surface. Often, this
// request also creates a new protocol object that represents the
// role and adds additional functionality to wl_surface. When a
// client wants to destroy a wl_surface, they must destroy this 'role
// object' before the wl_surface.
//
// Destroying the role object does not remove the role from the
// wl_surface, but it may stop the wl_surface from "playing the role".
// For instance, if a wl_subsurface object is destroyed, the wl_surface
// it was created for will be unmapped and forget its position and
// z-order. It is allowed to create a wl_subsurface for the same
// wl_surface again, but it is not allowed to use the wl_surface as
// a cursor (cursor is a different role than sub-surface, and role
// switching is not allowed).
type Surface struct {
	// Listener's methods are called by incoming messages from the
	// remote end via Dispatch. If it is nil, messages are silently
	// ignored.
	Listener SurfaceListener

	// OnDelete is called when the object is removed from the tracking
	// system.
	OnDelete func()

	state wire.State
	id    uint32
}

// NewSurface returns a newly instantiated Surface. It is
// primarily intended for use by generated code.
func NewSurface(state wire.State) *Surface {
	return &Surface{state: state}
}

func (obj *Surface) State() wire.State {
	return obj.state
}

func (obj *Surface) Dispatch(msg *wire.MessageBuffer) error {
	switch msg.Op() {
	case 0:
		if err := msg.Err(); err != nil {
			return err
		}

		if obj.Listener == nil {
			return nil
		}
		obj.Listener.Destroy()
		return nil

	case 1:
		buffer := NewBuffer(obj.state)
		buffer.SetID(msg.ReadUint())
		obj.state.Add(buffer)

		x := msg.ReadInt()

		y := msg.ReadInt()

		if err := msg.Err(); err != nil {
			return err
		}

		if obj.Listener == nil {
			return nil
		}
		obj.Listener.Attach(
			buffer,
			x,
			y,
		)
		return nil

	case 2:

		x := msg.ReadInt()

		y := msg.ReadInt()

		width := msg.ReadInt()

		height := msg.ReadInt()

		if err := msg.Err(); err != nil {
			return err
		}

		if obj.Listener == nil {
			return nil
		}
		obj.Listener.Damage(
			x,
			y,
			width,
			height,
		)
		return nil

	case 3:
		callback := NewCallback(obj.state)
		callback.SetID(msg.ReadUint())
		obj.state.Add(callback)

		if err := msg.Err(); err != nil {
			return err
		}

		if obj.Listener == nil {
			return nil
		}
		obj.Listener.Frame(
			callback,
		)
		return nil

	case 4:
		region := NewRegion(obj.state)
		region.SetID(msg.ReadUint())
		obj.state.Add(region)

		if err := msg.Err(); err != nil {
			return err
		}

		if obj.Listener == nil {
			return nil
		}
		obj.Listener.SetOpaqueRegion(
			region,
		)
		return nil

	case 5:
		region := NewRegion(obj.state)
		region.SetID(msg.ReadUint())
		obj.state.Add(region)

		if err := msg.Err(); err != nil {
			return err
		}

		if obj.Listener == nil {
			return nil
		}
		obj.Listener.SetInputRegion(
			region,
		)
		return nil

	case 6:
		if err := msg.Err(); err != nil {
			return err
		}

		if obj.Listener == nil {
			return nil
		}
		obj.Listener.Commit()
		return nil

	case 7:

		transform := OutputTransform(msg.ReadInt())

		if err := msg.Err(); err != nil {
			return err
		}

		if obj.Listener == nil {
			return nil
		}
		obj.Listener.SetBufferTransform(
			transform,
		)
		return nil

	case 8:

		scale := msg.ReadInt()

		if err := msg.Err(); err != nil {
			return err
		}

		if obj.Listener == nil {
			return nil
		}
		obj.Listener.SetBufferScale(
			scale,
		)
		return nil

	case 9:

		x := msg.ReadInt()

		y := msg.ReadInt()

		width := msg.ReadInt()

		height := msg.ReadInt()

		if err := msg.Err(); err != nil {
			return err
		}

		if obj.Listener == nil {
			return nil
		}
		obj.Listener.DamageBuffer(
			x,
			y,
			width,
			height,
		)
		return nil
	}

	return wire.UnknownOpError{
		Interface: "wl_surface",
		Type:      "request",
		Op:        msg.Op(),
	}
}

func (obj *Surface) ID() uint32 {
	return obj.id
}

func (obj *Surface) SetID(id uint32) {
	obj.id = id
}

func (obj *Surface) Delete() {
	if obj.OnDelete != nil {
		obj.OnDelete()
	}
}

func (obj *Surface) String() string {
	return fmt.Sprintf("%v(%v)", "wl_surface", obj.id)
}

func (obj *Surface) MethodName(op uint16) string {
	switch op {
	case 0:
		return "destroy"

	case 1:
		return "attach"

	case 2:
		return "damage"

	case 3:
		return "frame"

	case 4:
		return "set_opaque_region"

	case 5:
		return "set_input_region"

	case 6:
		return "commit"

	case 7:
		return "set_buffer_transform"

	case 8:
		return "set_buffer_scale"

	case 9:
		return "damage_buffer"
	}

	return "unknown method"
}

func (obj *Surface) Interface() string {
	return SurfaceInterface
}

func (obj *Surface) Version() uint32 {
	return SurfaceVersion
}

// This is emitted whenever a surface's creation, movement, or resizing
// results in some part of it being within the scanout region of an
// output.
//
// Note that a surface may be overlapping with zero or more outputs.
func (obj *Surface) Enter(output *Output) {
	builder := wire.NewMessage(obj, 0)
	builder.Method = "enter"
	builder.Args = []any{output}

	builder.WriteObject(output)

	obj.state.Enqueue(builder)
	return
}

// This is emitted whenever a surface's creation, movement, or resizing
// results in it no longer having any part of it within the scanout region
// of an output.
//
// Clients should not use the number of outputs the surface is on for frame
// throttling purposes. The surface might be hidden even if no leave event
// has been sent, and the compositor might expect new surface content
// updates even if no enter event has been sent. The frame event should be
// used instead.
func (obj *Surface) Leave(output *Output) {
	builder := wire.NewMessage(obj, 1)
	builder.Method = "leave"
	builder.Args = []any{output}

	builder.WriteObject(output)

	obj.state.Enqueue(builder)
	return
}

// These errors can be emitted in response to wl_surface requests.
type SurfaceError int64

const (
	// buffer scale value is invalid
	SurfaceErrorInvalidScale SurfaceError = 0

	// buffer transform value is invalid
	SurfaceErrorInvalidTransform SurfaceError = 1

	// buffer size is invalid
	SurfaceErrorInvalidSize SurfaceError = 2
)

func (enum SurfaceError) String() string {
	switch enum {
	case 0:
		return "SurfaceErrorInvalidScale"

	case 1:
		return "SurfaceErrorInvalidTransform"

	case 2:
		return "SurfaceErrorInvalidSize"
	}

	return "<invalid SurfaceError>"
}

const (
	SeatInterface = "wl_seat"
	SeatVersion   = 7
)

// SeatListener is a type that can respond to incoming
// messages for a Seat object.
type SeatListener interface {
	// The ID provided will be initialized to the wl_pointer interface
	// for this seat.
	//
	// This request only takes effect if the seat has the pointer
	// capability, or has had the pointer capability in the past.
	// It is a protocol violation to issue this request on a seat that has
	// never had the pointer capability. The missing_capability error will
	// be sent in this case.
	GetPointer(id *Pointer)

	// The ID provided will be initialized to the wl_keyboard interface
	// for this seat.
	//
	// This request only takes effect if the seat has the keyboard
	// capability, or has had the keyboard capability in the past.
	// It is a protocol violation to issue this request on a seat that has
	// never had the keyboard capability. The missing_capability error will
	// be sent in this case.
	GetKeyboard(id *Keyboard)

	// The ID provided will be initialized to the wl_touch interface
	// for this seat.
	//
	// This request only takes effect if the seat has the touch
	// capability, or has had the touch capability in the past.
	// It is a protocol violation to issue this request on a seat that has
	// never had the touch capability. The missing_capability error will
	// be sent in this case.
	GetTouch(id *Touch)

	// Using this request a client can tell the server that it is not going to
	// use the seat object anymore.
	Release()
}

// A seat is a group of keyboards, pointer and touch devices. This
// object is published as a global during start up, or when such a
// device is hot plugged.  A seat typically has a pointer and
// maintains a keyboard focus and a pointer focus.
type Seat struct {
	// Listener's methods are called by incoming messages from the
	// remote end via Dispatch. If it is nil, messages are silently
	// ignored.
	Listener SeatListener

	// OnDelete is called when the object is removed from the tracking
	// system.
	OnDelete func()

	state wire.State
	id    uint32
}

// NewSeat returns a newly instantiated Seat. It is
// primarily intended for use by generated code.
func NewSeat(state wire.State) *Seat {
	return &Seat{state: state}
}

func BindSeat(state wire.State, id wire.NewID) *Seat {
	obj := NewSeat(state)
	obj.SetID(id.ID)
	state.Add(obj)
	return obj
}

func (obj *Seat) State() wire.State {
	return obj.state
}

func (obj *Seat) Dispatch(msg *wire.MessageBuffer) error {
	switch msg.Op() {
	case 0:
		id := NewPointer(obj.state)
		id.SetID(msg.ReadUint())
		obj.state.Add(id)

		if err := msg.Err(); err != nil {
			return err
		}

		if obj.Listener == nil {
			return nil
		}
		obj.Listener.GetPointer(
			id,
		)
		return nil

	case 1:
		id := NewKeyboard(obj.state)
		id.SetID(msg.ReadUint())
		obj.state.Add(id)

		if err := msg.Err(); err != nil {
			return err
		}

		if obj.Listener == nil {
			return nil
		}
		obj.Listener.GetKeyboard(
			id,
		)
		return nil

	case 2:
		id := NewTouch(obj.state)
		id.SetID(msg.ReadUint())
		obj.state.Add(id)

		if err := msg.Err(); err != nil {
			return err
		}

		if obj.Listener == nil {
			return nil
		}
		obj.Listener.GetTouch(
			id,
		)
		return nil

	case 3:
		if err := msg.Err(); err != nil {
			return err
		}

		if obj.Listener == nil {
			return nil
		}
		obj.Listener.Release()
		return nil
	}

	return wire.UnknownOpError{
		Interface: "wl_seat",
		Type:      "request",
		Op:        msg.Op(),
	}
}

func (obj *Seat) ID() uint32 {
	return obj.id
}

func (obj *Seat) SetID(id uint32) {
	obj.id = id
}

func (obj *Seat) Delete() {
	if obj.OnDelete != nil {
		obj.OnDelete()
	}
}

func (obj *Seat) String() string {
	return fmt.Sprintf("%v(%v)", "wl_seat", obj.id)
}

func (obj *Seat) MethodName(op uint16) string {
	switch op {
	case 0:
		return "get_pointer"

	case 1:
		return "get_keyboard"

	case 2:
		return "get_touch"

	case 3:
		return "release"
	}

	return "unknown method"
}

func (obj *Seat) Interface() string {
	return SeatInterface
}

func (obj *Seat) Version() uint32 {
	return SeatVersion
}

// This is emitted whenever a seat gains or loses the pointer,
// keyboard or touch capabilities.  The argument is a capability
// enum containing the complete set of capabilities this seat has.
//
// When the pointer capability is added, a client may create a
// wl_pointer object using the wl_seat.get_pointer request. This object
// will receive pointer events until the capability is removed in the
// future.
//
// When the pointer capability is removed, a client should destroy the
// wl_pointer objects associated with the seat where the capability was
// removed, using the wl_pointer.release request. No further pointer
// events will be received on these objects.
//
// In some compositors, if a seat regains the pointer capability and a
// client has a previously obtained wl_pointer object of version 4 or
// less, that object may start sending pointer events again. This
// behavior is considered a misinterpretation of the intended behavior
// and must not be relied upon by the client. wl_pointer objects of
// version 5 or later must not send events if created before the most
// recent event notifying the client of an added pointer capability.
//
// The above behavior also applies to wl_keyboard and wl_touch with the
// keyboard and touch capabilities, respectively.
func (obj *Seat) Capabilities(capabilities SeatCapability) {
	builder := wire.NewMessage(obj, 0)
	builder.Method = "capabilities"
	builder.Args = []any{capabilities}

	builder.WriteUint(uint32(capabilities))

	obj.state.Enqueue(builder)
	return
}

// In a multiseat configuration this can be used by the client to help
// identify which physical devices the seat represents. Based on
// the seat configuration used by the compositor.
func (obj *Seat) Name(name string) {
	builder := wire.NewMessage(obj, 1)
	builder.Method = "name"
	builder.Args = []any{name}

	builder.WriteString(name)

	obj.state.Enqueue(builder)
	return
}

// This is a bitmask of capabilities this seat has; if a member is
// set, then it is present on the seat.
type SeatCapability int64

const (
	// the seat has pointer devices
	SeatCapabilityPointer SeatCapability = 1

	// the seat has one or more keyboards
	SeatCapabilityKeyboard SeatCapability = 2

	// the seat has touch devices
	SeatCapabilityTouch SeatCapability = 4
)

func (enum SeatCapability) String() string {
	switch enum {
	case 1:
		return "SeatCapabilityPointer"

	case 2:
		return "SeatCapabilityKeyboard"

	case 4:
		return "SeatCapabilityTouch"
	}

	return "<invalid SeatCapability>"
}

// These errors can be emitted in response to wl_seat requests.
type SeatError int64

const (
	// get_pointer, get_keyboard or get_touch called on seat without the matching capability
	SeatErrorMissingCapability SeatError = 0
)

func (enum SeatError) String() string {
	switch enum {
	case 0:
		return "SeatErrorMissingCapability"
	}

	return "<invalid SeatError>"
}

const (
	PointerInterface = "wl_pointer"
	PointerVersion   = 7
)

// PointerListener is a type that can respond to incoming
// messages for a Pointer object.
type PointerListener interface {
	// Set the pointer surface, i.e., the surface that contains the
	// pointer image (cursor). This request gives the surface the role
	// of a cursor. If the surface already has another role, it raises
	// a protocol error.
	//
	// The cursor actually changes only if the pointer
	// focus for this device is one of the requesting client's surfaces
	// or the surface parameter is the current pointer surface. If
	// there was a previous surface set with this request it is
	// replaced. If surface is NULL, the pointer image is hidden.
	//
	// The parameters hotspot_x and hotspot_y define the position of
	// the pointer surface relative to the pointer location. Its
	// top-left corner is always at (x, y) - (hotspot_x, hotspot_y),
	// where (x, y) are the coordinates of the pointer location, in
	// surface-local coordinates.
	//
	// On surface.attach requests to the pointer surface, hotspot_x
	// and hotspot_y are decremented by the x and y parameters
	// passed to the request. Attach must be confirmed by
	// wl_surface.commit as usual.
	//
	// The hotspot can also be updated by passing the currently set
	// pointer surface to this request with new values for hotspot_x
	// and hotspot_y.
	//
	// The current and pending input regions of the wl_surface are
	// cleared, and wl_surface.set_input_region is ignored until the
	// wl_surface is no longer used as the cursor. When the use as a
	// cursor ends, the current and pending input regions become
	// undefined, and the wl_surface is unmapped.
	SetCursor(serial uint32, surface *Surface, hotspotX int32, hotspotY int32)

	// Using this request a client can tell the server that it is not going to
	// use the pointer object anymore.
	//
	// This request destroys the pointer proxy object, so clients must not call
	// wl_pointer_destroy() after using this request.
	Release()
}

// The wl_pointer interface represents one or more input devices,
// such as mice, which control the pointer location and pointer_focus
// of a seat.
//
// The wl_pointer interface generates motion, enter and leave
// events for the surfaces that the pointer is located over,
// and button and axis events for button presses, button releases
// and scrolling.
type Pointer struct {
	// Listener's methods are called by incoming messages from the
	// remote end via Dispatch. If it is nil, messages are silently
	// ignored.
	Listener PointerListener

	// OnDelete is called when the object is removed from the tracking
	// system.
	OnDelete func()

	state wire.State
	id    uint32
}

// NewPointer returns a newly instantiated Pointer. It is
// primarily intended for use by generated code.
func NewPointer(state wire.State) *Pointer {
	return &Pointer{state: state}
}

func (obj *Pointer) State() wire.State {
	return obj.state
}

func (obj *Pointer) Dispatch(msg *wire.MessageBuffer) error {
	switch msg.Op() {
	case 0:

		serial := msg.ReadUint()

		surface := NewSurface(obj.state)
		surface.SetID(msg.ReadUint())
		obj.state.Add(surface)

		hotspotX := msg.ReadInt()

		hotspotY := msg.ReadInt()

		if err := msg.Err(); err != nil {
			return err
		}

		if obj.Listener == nil {
			return nil
		}
		obj.Listener.SetCursor(
			serial,
			surface,
			hotspotX,
			hotspotY,
		)
		return nil

	case 1:
		if err := msg.Err(); err != nil {
			return err
		}

		if obj.Listener == nil {
			return nil
		}
		obj.Listener.Release()
		return nil
	}

	return wire.UnknownOpError{
		Interface: "wl_pointer",
		Type:      "request",
		Op:        msg.Op(),
	}
}

func (obj *Pointer) ID() uint32 {
	return obj.id
}

func (obj *Pointer) SetID(id uint32) {
	obj.id = id
}

func (obj *Pointer) Delete() {
	if obj.OnDelete != nil {
		obj.OnDelete()
	}
}

func (obj *Pointer) String() string {
	return fmt.Sprintf("%v(%v)", "wl_pointer", obj.id)
}

func (obj *Pointer) MethodName(op uint16) string {
	switch op {
	case 0:
		return "set_cursor"

	case 1:
		return "release"
	}

	return "unknown method"
}

func (obj *Pointer) Interface() string {
	return PointerInterface
}

func (obj *Pointer) Version() uint32 {
	return PointerVersion
}

// Notification that this seat's pointer is focused on a certain
// surface.
//
// When a seat's focus enters a surface, the pointer image
// is undefined and a client should respond to this event by setting
// an appropriate pointer image with the set_cursor request.
func (obj *Pointer) Enter(serial uint32, surface *Surface, surfaceX wire.Fixed, surfaceY wire.Fixed) {
	builder := wire.NewMessage(obj, 0)
	builder.Method = "enter"
	builder.Args = []any{serial, surface, surfaceX, surfaceY}

	builder.WriteUint(serial)
	builder.WriteObject(surface)
	builder.WriteFixed(surfaceX)
	builder.WriteFixed(surfaceY)

	obj.state.Enqueue(builder)
	return
}

// Notification that this seat's pointer is no longer focused on
// a certain surface.
//
// The leave notification is sent before the enter notification
// for the new focus.
func (obj *Pointer) Leave(serial uint32, surface *Surface) {
	builder := wire.NewMessage(obj, 1)
	builder.Method = "leave"
	builder.Args = []any{serial, surface}

	builder.WriteUint(serial)
	builder.WriteObject(surface)

	obj.state.Enqueue(builder)
	return
}

// Notification of pointer location change. The arguments
// surface_x and surface_y are the location relative to the
// focused surface.
func (obj *Pointer) Motion(time uint32, surfaceX wire.Fixed, surfaceY wire.Fixed) {
	builder := wire.NewMessage(obj, 2)
	builder.Method = "motion"
	builder.Args = []any{time, surfaceX, surfaceY}

	builder.WriteUint(time)
	builder.WriteFixed(surfaceX)
	builder.WriteFixed(surfaceY)

	obj.state.Enqueue(builder)
	return
}

// Mouse button click and release notifications.
//
// The location of the click is given by the last motion or
// enter event.
// The time argument is a timestamp with millisecond
// granularity, with an undefined base.
//
// The button is a button code as defined in the Linux kernel's
// linux/input-event-codes.h header file, e.g. BTN_LEFT.
//
// Any 16-bit button code value is reserved for future additions to the
// kernel's event code list. All other button codes above 0xFFFF are
// currently undefined but may be used in future versions of this
// protocol.
func (obj *Pointer) Button(serial uint32, time uint32, button uint32, state PointerButtonState) {
	builder := wire.NewMessage(obj, 3)
	builder.Method = "button"
	builder.Args = []any{serial, time, button, state}

	builder.WriteUint(serial)
	builder.WriteUint(time)
	builder.WriteUint(button)
	builder.WriteUint(uint32(state))

	obj.state.Enqueue(builder)
	return
}

// Scroll and other axis notifications.
//
// For scroll events (vertical and horizontal scroll axes), the
// value parameter is the length of a vector along the specified
// axis in a coordinate space identical to those of motion events,
// representing a relative movement along the specified axis.
//
// For devices that support movements non-parallel to axes multiple
// axis events will be emitted.
//
// When applicable, for example for touch pads, the server can
// choose to emit scroll events where the motion vector is
// equivalent to a motion event vector.
//
// When applicable, a client can transform its content relative to the
// scroll distance.
func (obj *Pointer) Axis(time uint32, axis PointerAxis, value wire.Fixed) {
	builder := wire.NewMessage(obj, 4)
	builder.Method = "axis"
	builder.Args = []any{time, axis, value}

	builder.WriteUint(time)
	builder.WriteUint(uint32(axis))
	builder.WriteFixed(value)

	obj.state.Enqueue(builder)
	return
}

// Indicates the end of a set of events that logically belong together.
// A client is expected to accumulate the data in all events within the
// frame before proceeding.
//
// All wl_pointer events before a wl_pointer.frame event belong
// logically together. For example, in a diagonal scroll motion the
// compositor will send an optional wl_pointer.axis_source event, two
// wl_pointer.axis events (horizontal and vertical) and finally a
// wl_pointer.frame event. The client may use this information to
// calculate a diagonal vector for scrolling.
//
// When multiple wl_pointer.axis events occur within the same frame,
// the motion vector is the combined motion of all events.
// When a wl_pointer.axis and a wl_pointer.axis_stop event occur within
// the same frame, this indicates that axis movement in one axis has
// stopped but continues in the other axis.
// When multiple wl_pointer.axis_stop events occur within the same
// frame, this indicates that these axes stopped in the same instance.
//
// A wl_pointer.frame event is sent for every logical event group,
// even if the group only contains a single wl_pointer event.
// Specifically, a client may get a sequence: motion, frame, button,
// frame, axis, frame, axis_stop, frame.
//
// The wl_pointer.enter and wl_pointer.leave events are logical events
// generated by the compositor and not the hardware. These events are
// also grouped by a wl_pointer.frame. When a pointer moves from one
// surface to another, a compositor should group the
// wl_pointer.leave event within the same wl_pointer.frame.
// However, a client must not rely on wl_pointer.leave and
// wl_pointer.enter being in the same wl_pointer.frame.
// Compositor-specific policies may require the wl_pointer.leave and
// wl_pointer.enter event being split across multiple wl_pointer.frame
// groups.
func (obj *Pointer) Frame() {
	builder := wire.NewMessage(obj, 5)
	builder.Method = "frame"
	builder.Args = []any{}

	obj.state.Enqueue(builder)
	return
}

// Source information for scroll and other axes.
//
// This event does not occur on its own. It is sent before a
// wl_pointer.frame event and carries the source information for
// all events within that frame.
//
// The source specifies how this event was generated. If the source is
// wl_pointer.axis_source.finger, a wl_pointer.axis_stop event will be
// sent when the user lifts the finger off the device.
//
// If the source is wl_pointer.axis_source.wheel,
// wl_pointer.axis_source.wheel_tilt or
// wl_pointer.axis_source.continuous, a wl_pointer.axis_stop event may
// or may not be sent. Whether a compositor sends an axis_stop event
// for these sources is hardware-specific and implementation-dependent;
// clients must not rely on receiving an axis_stop event for these
// scroll sources and should treat scroll sequences from these scroll
// sources as unterminated by default.
//
// This event is optional. If the source is unknown for a particular
// axis event sequence, no event is sent.
// Only one wl_pointer.axis_source event is permitted per frame.
//
// The order of wl_pointer.axis_discrete and wl_pointer.axis_source is
// not guaranteed.
func (obj *Pointer) AxisSource(axisSource PointerAxisSource) {
	builder := wire.NewMessage(obj, 6)
	builder.Method = "axis_source"
	builder.Args = []any{axisSource}

	builder.WriteUint(uint32(axisSource))

	obj.state.Enqueue(builder)
	return
}

// Stop notification for scroll and other axes.
//
// For some wl_pointer.axis_source types, a wl_pointer.axis_stop event
// is sent to notify a client that the axis sequence has terminated.
// This enables the client to implement kinetic scrolling.
// See the wl_pointer.axis_source documentation for information on when
// this event may be generated.
//
// Any wl_pointer.axis events with the same axis_source after this
// event should be considered as the start of a new axis motion.
//
// The timestamp is to be interpreted identical to the timestamp in the
// wl_pointer.axis event. The timestamp value may be the same as a
// preceding wl_pointer.axis event.
func (obj *Pointer) AxisStop(time uint32, axis PointerAxis) {
	builder := wire.NewMessage(obj, 7)
	builder.Method = "axis_stop"
	builder.Args = []any{time, axis}

	builder.WriteUint(time)
	builder.WriteUint(uint32(axis))

	obj.state.Enqueue(builder)
	return
}

// Discrete step information for scroll and other axes.
//
// This event carries the axis value of the wl_pointer.axis event in
// discrete steps (e.g. mouse wheel clicks).
//
// This event does not occur on its own, it is coupled with a
// wl_pointer.axis event that represents this axis value on a
// continuous scale. The protocol guarantees that each axis_discrete
// event is always followed by exactly one axis event with the same
// axis number within the same wl_pointer.frame. Note that the protocol
// allows for other events to occur between the axis_discrete and
// its coupled axis event, including other axis_discrete or axis
// events.
//
// This event is optional; continuous scrolling devices
// like two-finger scrolling on touchpads do not have discrete
// steps and do not generate this event.
//
// The discrete value carries the directional information. e.g. a value
// of -2 is two steps towards the negative direction of this axis.
//
// The axis number is identical to the axis number in the associated
// axis event.
//
// The order of wl_pointer.axis_discrete and wl_pointer.axis_source is
// not guaranteed.
func (obj *Pointer) AxisDiscrete(axis PointerAxis, discrete int32) {
	builder := wire.NewMessage(obj, 8)
	builder.Method = "axis_discrete"
	builder.Args = []any{axis, discrete}

	builder.WriteUint(uint32(axis))
	builder.WriteInt(discrete)

	obj.state.Enqueue(builder)
	return
}

type PointerError int64

const (
	// given wl_surface has another role
	PointerErrorRole PointerError = 0
)

func (enum PointerError) String() string {
	switch enum {
	case 0:
		return "PointerErrorRole"
	}

	return "<invalid PointerError>"
}

// Describes the physical state of a button that produced the button
// event.
type PointerButtonState int64

const (
	// the button is not pressed
	PointerButtonStateReleased PointerButtonState = 0

	// the button is pressed
	PointerButtonStatePressed PointerButtonState = 1
)

func (enum PointerButtonState) String() string {
	switch enum {
	case 0:
		return "PointerButtonStateReleased"

	case 1:
		return "PointerButtonStatePressed"
	}

	return "<invalid PointerButtonState>"
}

// Describes the axis types of scroll events.
type PointerAxis int64

const (
	// vertical axis
	PointerAxisVerticalScroll PointerAxis = 0

	// horizontal axis
	PointerAxisHorizontalScroll PointerAxis = 1
)

func (enum PointerAxis) String() string {
	switch enum {
	case 0:
		return "PointerAxisVerticalScroll"

	case 1:
		return "PointerAxisHorizontalScroll"
	}

	return "<invalid PointerAxis>"
}

// Describes the source types for axis events. This indicates to the
// client how an axis event was physically generated; a client may
// adjust the user interface accordingly. For example, scroll events
// from a "finger" source may be in a smooth coordinate space with
// kinetic scrolling whereas a "wheel" source may be in discrete steps
// of a number of lines.
//
// The "continuous" axis source is a device generating events in a
// continuous coordinate space, but using something other than a
// finger. One example for this source is button-based scrolling where
// the vertical motion of a device is converted to scroll events while
// a button is held down.
//
// The "wheel tilt" axis source indicates that the actual device is a
// wheel but the scroll event is not caused by a rotation but a
// (usually sideways) tilt of the wheel.
type PointerAxisSource int64

const (
	// a physical wheel rotation
	PointerAxisSourceWheel PointerAxisSource = 0

	// finger on a touch surface
	PointerAxisSourceFinger PointerAxisSource = 1

	// continuous coordinate space
	PointerAxisSourceContinuous PointerAxisSource = 2

	// a physical wheel tilt
	PointerAxisSourceWheelTilt PointerAxisSource = 3
)

func (enum PointerAxisSource) String() string {
	switch enum {
	case 0:
		return "PointerAxisSourceWheel"

	case 1:
		return "PointerAxisSourceFinger"

	case 2:
		return "PointerAxisSourceContinuous"

	case 3:
		return "PointerAxisSourceWheelTilt"
	}

	return "<invalid PointerAxisSource>"
}

const (
	KeyboardInterface = "wl_keyboard"
	KeyboardVersion   = 7
)

// KeyboardListener is a type that can respond to incoming
// messages for a Keyboard object.
type KeyboardListener interface {
	Release()
}

// The wl_keyboard interface represents one or more keyboards
// associated with a seat.
type Keyboard struct {
	// Listener's methods are called by incoming messages from the
	// remote end via Dispatch. If it is nil, messages are silently
	// ignored.
	Listener KeyboardListener

	// OnDelete is called when the object is removed from the tracking
	// system.
	OnDelete func()

	state wire.State
	id    uint32
}

// NewKeyboard returns a newly instantiated Keyboard. It is
// primarily intended for use by generated code.
func NewKeyboard(state wire.State) *Keyboard {
	return &Keyboard{state: state}
}

func (obj *Keyboard) State() wire.State {
	return obj.state
}

func (obj *Keyboard) Dispatch(msg *wire.MessageBuffer) error {
	switch msg.Op() {
	case 0:
		if err := msg.Err(); err != nil {
			return err
		}

		if obj.Listener == nil {
			return nil
		}
		obj.Listener.Release()
		return nil
	}

	return wire.UnknownOpError{
		Interface: "wl_keyboard",
		Type:      "request",
		Op:        msg.Op(),
	}
}

func (obj *Keyboard) ID() uint32 {
	return obj.id
}

func (obj *Keyboard) SetID(id uint32) {
	obj.id = id
}

func (obj *Keyboard) Delete() {
	if obj.OnDelete != nil {
		obj.OnDelete()
	}
}

func (obj *Keyboard) String() string {
	return fmt.Sprintf("%v(%v)", "wl_keyboard", obj.id)
}

func (obj *Keyboard) MethodName(op uint16) string {
	switch op {
	case 0:
		return "release"
	}

	return "unknown method"
}

func (obj *Keyboard) Interface() string {
	return KeyboardInterface
}

func (obj *Keyboard) Version() uint32 {
	return KeyboardVersion
}

// This event provides a file descriptor to the client which can be
// memory-mapped to provide a keyboard mapping description.
//
// From version 7 onwards, the fd must be mapped with MAP_PRIVATE by
// the recipient, as MAP_SHARED may fail.
func (obj *Keyboard) Keymap(format KeyboardKeymapFormat, fd *os.File, size uint32) {
	builder := wire.NewMessage(obj, 0)
	builder.Method = "keymap"
	builder.Args = []any{format, fd, size}

	builder.WriteUint(uint32(format))
	builder.WriteFile(fd)
	builder.WriteUint(size)

	obj.state.Enqueue(builder)
	return
}

// Notification that this seat's keyboard focus is on a certain
// surface.
//
// The compositor must send the wl_keyboard.modifiers event after this
// event.
func (obj *Keyboard) Enter(serial uint32, surface *Surface, keys []byte) {
	builder := wire.NewMessage(obj, 1)
	builder.Method = "enter"
	builder.Args = []any{serial, surface, keys}

	builder.WriteUint(serial)
	builder.WriteObject(surface)
	builder.WriteArray(keys)

	obj.state.Enqueue(builder)
	return
}

// Notification that this seat's keyboard focus is no longer on
// a certain surface.
//
// The leave notification is sent before the enter notification
// for the new focus.
//
// After this event client must assume that all keys, including modifiers,
// are lifted and also it must stop key repeating if there's some going on.
func (obj *Keyboard) Leave(serial uint32, surface *Surface) {
	builder := wire.NewMessage(obj, 2)
	builder.Method = "leave"
	builder.Args = []any{serial, surface}

	builder.WriteUint(serial)
	builder.WriteObject(surface)

	obj.state.Enqueue(builder)
	return
}

// A key was pressed or released.
// The time argument is a timestamp with millisecond
// granularity, with an undefined base.
//
// The key is a platform-specific key code that can be interpreted
// by feeding it to the keyboard mapping (see the keymap event).
//
// If this event produces a change in modifiers, then the resulting
// wl_keyboard.modifiers event must be sent after this event.
func (obj *Keyboard) Key(serial uint32, time uint32, key uint32, state KeyboardKeyState) {
	builder := wire.NewMessage(obj, 3)
	builder.Method = "key"
	builder.Args = []any{serial, time, key, state}

	builder.WriteUint(serial)
	builder.WriteUint(time)
	builder.WriteUint(key)
	builder.WriteUint(uint32(state))

	obj.state.Enqueue(builder)
	return
}

// Notifies clients that the modifier and/or group state has
// changed, and it should update its local state.
func (obj *Keyboard) Modifiers(serial uint32, modsDepressed uint32, modsLatched uint32, modsLocked uint32, group uint32) {
	builder := wire.NewMessage(obj, 4)
	builder.Method = "modifiers"
	builder.Args = []any{serial, modsDepressed, modsLatched, modsLocked, group}

	builder.WriteUint(serial)
	builder.WriteUint(modsDepressed)
	builder.WriteUint(modsLatched)
	builder.WriteUint(modsLocked)
	builder.WriteUint(group)

	obj.state.Enqueue(builder)
	return
}

// Informs the client about the keyboard's repeat rate and delay.
//
// This event is sent as soon as the wl_keyboard object has been created,
// and is guaranteed to be received by the client before any key press
// event.
//
// Negative values for either rate or delay are illegal. A rate of zero
// will disable any repeating (regardless of the value of delay).
//
// This event can be sent later on as well with a new value if necessary,
// so clients should continue listening for the event past the creation
// of wl_keyboard.
func (obj *Keyboard) RepeatInfo(rate int32, delay int32) {
	builder := wire.NewMessage(obj, 5)
	builder.Method = "repeat_info"
	builder.Args = []any{rate, delay}

	builder.WriteInt(rate)
	builder.WriteInt(delay)

	obj.state.Enqueue(builder)
	return
}

// This specifies the format of the keymap provided to the
// client with the wl_keyboard.keymap event.
type KeyboardKeymapFormat int64

const (
	// no keymap; client must understand how to interpret the raw keycode
	KeyboardKeymapFormatNoKeymap KeyboardKeymapFormat = 0

	// libxkbcommon compatible; to determine the xkb keycode, clients must add 8 to the key event keycode
	KeyboardKeymapFormatXkbV1 KeyboardKeymapFormat = 1
)

func (enum KeyboardKeymapFormat) String() string {
	switch enum {
	case 0:
		return "KeyboardKeymapFormatNoKeymap"

	case 1:
		return "KeyboardKeymapFormatXkbV1"
	}

	return "<invalid KeyboardKeymapFormat>"
}

// Describes the physical state of a key that produced the key event.
type KeyboardKeyState int64

const (
	// key is not pressed
	KeyboardKeyStateReleased KeyboardKeyState = 0

	// key is pressed
	KeyboardKeyStatePressed KeyboardKeyState = 1
)

func (enum KeyboardKeyState) String() string {
	switch enum {
	case 0:
		return "KeyboardKeyStateReleased"

	case 1:
		return "KeyboardKeyStatePressed"
	}

	return "<invalid KeyboardKeyState>"
}

const (
	TouchInterface = "wl_touch"
	TouchVersion   = 7
)

// TouchListener is a type that can respond to incoming
// messages for a Touch object.
type TouchListener interface {
	Release()
}

// The wl_touch interface represents a touchscreen
// associated with a seat.
//
// Touch interactions can consist of one or more contacts.
// For each contact, a series of events is generated, starting
// with a down event, followed by zero or more motion events,
// and ending with an up event. Events relating to the same
// contact point can be identified by the ID of the sequence.
type Touch struct {
	// Listener's methods are called by incoming messages from the
	// remote end via Dispatch. If it is nil, messages are silently
	// ignored.
	Listener TouchListener

	// OnDelete is called when the object is removed from the tracking
	// system.
	OnDelete func()

	state wire.State
	id    uint32
}

// NewTouch returns a newly instantiated Touch. It is
// primarily intended for use by generated code.
func NewTouch(state wire.State) *Touch {
	return &Touch{state: state}
}

func (obj *Touch) State() wire.State {
	return obj.state
}

func (obj *Touch) Dispatch(msg *wire.MessageBuffer) error {
	switch msg.Op() {
	case 0:
		if err := msg.Err(); err != nil {
			return err
		}

		if obj.Listener == nil {
			return nil
		}
		obj.Listener.Release()
		return nil
	}

	return wire.UnknownOpError{
		Interface: "wl_touch",
		Type:      "request",
		Op:        msg.Op(),
	}
}

func (obj *Touch) ID() uint32 {
	return obj.id
}

func (obj *Touch) SetID(id uint32) {
	obj.id = id
}

func (obj *Touch) Delete() {
	if obj.OnDelete != nil {
		obj.OnDelete()
	}
}

func (obj *Touch) String() string {
	return fmt.Sprintf("%v(%v)", "wl_touch", obj.id)
}

func (obj *Touch) MethodName(op uint16) string {
	switch op {
	case 0:
		return "release"
	}

	return "unknown method"
}

func (obj *Touch) Interface() string {
	return TouchInterface
}

func (obj *Touch) Version() uint32 {
	return TouchVersion
}

// A new touch point has appeared on the surface. This touch point is
// assigned a unique ID. Future events from this touch point reference
// this ID. The ID ceases to be valid after a touch up event and may be
// reused in the future.
func (obj *Touch) Down(serial uint32, time uint32, surface *Surface, id int32, x wire.Fixed, y wire.Fixed) {
	builder := wire.NewMessage(obj, 0)
	builder.Method = "down"
	builder.Args = []any{serial, time, surface, id, x, y}

	builder.WriteUint(serial)
	builder.WriteUint(time)
	builder.WriteObject(surface)
	builder.WriteInt(id)
	builder.WriteFixed(x)
	builder.WriteFixed(y)

	obj.state.Enqueue(builder)
	return
}

// The touch point has disappeared. No further events will be sent for
// this touch point and the touch point's ID is released and may be
// reused in a future touch down event.
func (obj *Touch) Up(serial uint32, time uint32, id int32) {
	builder := wire.NewMessage(obj, 1)
	builder.Method = "up"
	builder.Args = []any{serial, time, id}

	builder.WriteUint(serial)
	builder.WriteUint(time)
	builder.WriteInt(id)

	obj.state.Enqueue(builder)
	return
}

// A touch point has changed coordinates.
func (obj *Touch) Motion(time uint32, id int32, x wire.Fixed, y wire.Fixed) {
	builder := wire.NewMessage(obj, 2)
	builder.Method = "motion"
	builder.Args = []any{time, id, x, y}

	builder.WriteUint(time)
	builder.WriteInt(id)
	builder.WriteFixed(x)
	builder.WriteFixed(y)

	obj.state.Enqueue(builder)
	return
}

// Indicates the end of a set of events that logically belong together.
// A client is expected to accumulate the data in all events within the
// frame before proceeding.
//
// A wl_touch.frame terminates at least one event but otherwise no
// guarantee is provided about the set of events within a frame. A client
// must assume that any state not updated in a frame is unchanged from the
// previously known state.
func (obj *Touch) Frame() {
	builder := wire.NewMessage(obj, 3)
	builder.Method = "frame"
	builder.Args = []any{}

	obj.state.Enqueue(builder)
	return
}

// Sent if the compositor decides the touch stream is a global
// gesture. No further events are sent to the clients from that
// particular gesture. Touch cancellation applies to all touch points
// currently active on this client's surface. The client is
// responsible for finalizing the touch points, future touch points on
// this surface may reuse the touch point ID.
func (obj *Touch) Cancel() {
	builder := wire.NewMessage(obj, 4)
	builder.Method = "cancel"
	builder.Args = []any{}

	obj.state.Enqueue(builder)
	return
}

// Sent when a touchpoint has changed its shape.
//
// This event does not occur on its own. It is sent before a
// wl_touch.frame event and carries the new shape information for
// any previously reported, or new touch points of that frame.
//
// Other events describing the touch point such as wl_touch.down,
// wl_touch.motion or wl_touch.orientation may be sent within the
// same wl_touch.frame. A client should treat these events as a single
// logical touch point update. The order of wl_touch.shape,
// wl_touch.orientation and wl_touch.motion is not guaranteed.
// A wl_touch.down event is guaranteed to occur before the first
// wl_touch.shape event for this touch ID but both events may occur within
// the same wl_touch.frame.
//
// A touchpoint shape is approximated by an ellipse through the major and
// minor axis length. The major axis length describes the longer diameter
// of the ellipse, while the minor axis length describes the shorter
// diameter. Major and minor are orthogonal and both are specified in
// surface-local coordinates. The center of the ellipse is always at the
// touchpoint location as reported by wl_touch.down or wl_touch.move.
//
// This event is only sent by the compositor if the touch device supports
// shape reports. The client has to make reasonable assumptions about the
// shape if it did not receive this event.
func (obj *Touch) Shape(id int32, major wire.Fixed, minor wire.Fixed) {
	builder := wire.NewMessage(obj, 5)
	builder.Method = "shape"
	builder.Args = []any{id, major, minor}

	builder.WriteInt(id)
	builder.WriteFixed(major)
	builder.WriteFixed(minor)

	obj.state.Enqueue(builder)
	return
}

// Sent when a touchpoint has changed its orientation.
//
// This event does not occur on its own. It is sent before a
// wl_touch.frame event and carries the new shape information for
// any previously reported, or new touch points of that frame.
//
// Other events describing the touch point such as wl_touch.down,
// wl_touch.motion or wl_touch.shape may be sent within the
// same wl_touch.frame. A client should treat these events as a single
// logical touch point update. The order of wl_touch.shape,
// wl_touch.orientation and wl_touch.motion is not guaranteed.
// A wl_touch.down event is guaranteed to occur before the first
// wl_touch.orientation event for this touch ID but both events may occur
// within the same wl_touch.frame.
//
// The orientation describes the clockwise angle of a touchpoint's major
// axis to the positive surface y-axis and is normalized to the -180 to
// +180 degree range. The granularity of orientation depends on the touch
// device, some devices only support binary rotation values between 0 and
// 90 degrees.
//
// This event is only sent by the compositor if the touch device supports
// orientation reports.
func (obj *Touch) Orientation(id int32, orientation wire.Fixed) {
	builder := wire.NewMessage(obj, 6)
	builder.Method = "orientation"
	builder.Args = []any{id, orientation}

	builder.WriteInt(id)
	builder.WriteFixed(orientation)

	obj.state.Enqueue(builder)
	return
}

const (
	OutputInterface = "wl_output"
	OutputVersion   = 3
)

// OutputListener is a type that can respond to incoming
// messages for a Output object.
type OutputListener interface {
	// Using this request a client can tell the server that it is not going to
	// use the output object anymore.
	Release()
}

// An output describes part of the compositor geometry.  The
// compositor works in the 'compositor coordinate system' and an
// output corresponds to a rectangular area in that space that is
// actually visible.  This typically corresponds to a monitor that
// displays part of the compositor space.  This object is published
// as global during start up, or when a monitor is hotplugged.
type Output struct {
	// Listener's methods are called by incoming messages from the
	// remote end via Dispatch. If it is nil, messages are silently
	// ignored.
	Listener OutputListener

	// OnDelete is called when the object is removed from the tracking
	// system.
	OnDelete func()

	state wire.State
	id    uint32
}

// NewOutput returns a newly instantiated Output. It is
// primarily intended for use by generated code.
func NewOutput(state wire.State) *Output {
	return &Output{state: state}
}

func BindOutput(state wire.State, id wire.NewID) *Output {
	obj := NewOutput(state)
	obj.SetID(id.ID)
	state.Add(obj)
	return obj
}

func (obj *Output) State() wire.State {
	return obj.state
}

func (obj *Output) Dispatch(msg *wire.MessageBuffer) error {
	switch msg.Op() {
	case 0:
		if err := msg.Err(); err != nil {
			return err
		}

		if obj.Listener == nil {
			return nil
		}
		obj.Listener.Release()
		return nil
	}

	return wire.UnknownOpError{
		Interface: "wl_output",
		Type:      "request",
		Op:        msg.Op(),
	}
}

func (obj *Output) ID() uint32 {
	return obj.id
}

func (obj *Output) SetID(id uint32) {
	obj.id = id
}

func (obj *Output) Delete() {
	if obj.OnDelete != nil {
		obj.OnDelete()
	}
}

func (obj *Output) String() string {
	return fmt.Sprintf("%v(%v)", "wl_output", obj.id)
}

func (obj *Output) MethodName(op uint16) string {
	switch op {
	case 0:
		return "release"
	}

	return "unknown method"
}

func (obj *Output) Interface() string {
	return OutputInterface
}

func (obj *Output) Version() uint32 {
	return OutputVersion
}

// The geometry event describes geometric properties of the output.
// The event is sent when binding to the output object and whenever
// any of the properties change.
//
// The physical size can be set to zero if it doesn't make sense for this
// output (e.g. for projectors or virtual outputs).
//
// Note: wl_output only advertises partial information about the output
// position and identification. Some compositors, for instance those not
// implementing a desktop-style output layout or those exposing virtual
// outputs, might fake this information. Instead of using x and y, clients
// should use xdg_output.logical_position. Instead of using make and model,
// clients should use xdg_output.name and xdg_output.description.
func (obj *Output) Geometry(x int32, y int32, physicalWidth int32, physicalHeight int32, subpixel OutputSubpixel, make string, model string, transform OutputTransform) {
	builder := wire.NewMessage(obj, 0)
	builder.Method = "geometry"
	builder.Args = []any{x, y, physicalWidth, physicalHeight, subpixel, make, model, transform}

	builder.WriteInt(x)
	builder.WriteInt(y)
	builder.WriteInt(physicalWidth)
	builder.WriteInt(physicalHeight)
	builder.WriteInt(int32(subpixel))
	builder.WriteString(make)
	builder.WriteString(model)
	builder.WriteInt(int32(transform))

	obj.state.Enqueue(builder)
	return
}

// The mode event describes an available mode for the output.
//
// The event is sent when binding to the output object and there
// will always be one mode, the current mode.  The event is sent
// again if an output changes mode, for the mode that is now
// current.  In other words, the current mode is always the last
// mode that was received with the current flag set.
//
// Non-current modes are deprecated. A compositor can decide to only
// advertise the current mode and never send other modes. Clients
// should not rely on non-current modes.
//
// The size of a mode is given in physical hardware units of
// the output device. This is not necessarily the same as
// the output size in the global compositor space. For instance,
// the output may be scaled, as described in wl_output.scale,
// or transformed, as described in wl_output.transform. Clients
// willing to retrieve the output size in the global compositor
// space should use xdg_output.logical_size instead.
//
// The vertical refresh rate can be set to zero if it doesn't make
// sense for this output (e.g. for virtual outputs).
//
// Clients should not use the refresh rate to schedule frames. Instead,
// they should use the wl_surface.frame event or the presentation-time
// protocol.
//
// Note: this information is not always meaningful for all outputs. Some
// compositors, such as those exposing virtual outputs, might fake the
// refresh rate or the size.
func (obj *Output) Mode(flags OutputMode, width int32, height int32, refresh int32) {
	builder := wire.NewMessage(obj, 1)
	builder.Method = "mode"
	builder.Args = []any{flags, width, height, refresh}

	builder.WriteUint(uint32(flags))
	builder.WriteInt(width)
	builder.WriteInt(height)
	builder.WriteInt(refresh)

	obj.state.Enqueue(builder)
	return
}

// This event is sent after all other properties have been
// sent after binding to the output object and after any
// other property changes done after that. This allows
// changes to the output properties to be seen as
// atomic, even if they happen via multiple events.
func (obj *Output) Done() {
	builder := wire.NewMessage(obj, 2)
	builder.Method = "done"
	builder.Args = []any{}

	obj.state.Enqueue(builder)
	return
}

// This event contains scaling geometry information
// that is not in the geometry event. It may be sent after
// binding the output object or if the output scale changes
// later. If it is not sent, the client should assume a
// scale of 1.
//
// A scale larger than 1 means that the compositor will
// automatically scale surface buffers by this amount
// when rendering. This is used for very high resolution
// displays where applications rendering at the native
// resolution would be too small to be legible.
//
// It is intended that scaling aware clients track the
// current output of a surface, and if it is on a scaled
// output it should use wl_surface.set_buffer_scale with
// the scale of the output. That way the compositor can
// avoid scaling the surface, and the client can supply
// a higher detail image.
func (obj *Output) Scale(factor int32) {
	builder := wire.NewMessage(obj, 3)
	builder.Method = "scale"
	builder.Args = []any{factor}

	builder.WriteInt(factor)

	obj.state.Enqueue(builder)
	return
}

// This enumeration describes how the physical
// pixels on an output are laid out.
type OutputSubpixel int64

const (
	// unknown geometry
	OutputSubpixelUnknown OutputSubpixel = 0

	// no geometry
	OutputSubpixelNone OutputSubpixel = 1

	// horizontal RGB
	OutputSubpixelHorizontalRgb OutputSubpixel = 2

	// horizontal BGR
	OutputSubpixelHorizontalBgr OutputSubpixel = 3

	// vertical RGB
	OutputSubpixelVerticalRgb OutputSubpixel = 4

	// vertical BGR
	OutputSubpixelVerticalBgr OutputSubpixel = 5
)

func (enum OutputSubpixel) String() string {
	switch enum {
	case 0:
		return "OutputSubpixelUnknown"

	case 1:
		return "OutputSubpixelNone"

	case 2:
		return "OutputSubpixelHorizontalRgb"

	case 3:
		return "OutputSubpixelHorizontalBgr"

	case 4:
		return "OutputSubpixelVerticalRgb"

	case 5:
		return "OutputSubpixelVerticalBgr"
	}

	return "<invalid OutputSubpixel>"
}

// This describes the transform that a compositor will apply to a
// surface to compensate for the rotation or mirroring of an
// output device.
//
// The flipped values correspond to an initial flip around a
// vertical axis followed by rotation.
//
// The purpose is mainly to allow clients to render accordingly and
// tell the compositor, so that for fullscreen surfaces, the
// compositor will still be able to scan out directly from client
// surfaces.
type OutputTransform int64

const (
	// no transform
	OutputTransformNormal OutputTransform = 0

	// 90 degrees counter-clockwise
	OutputTransform90 OutputTransform = 1

	// 180 degrees counter-clockwise
	OutputTransform180 OutputTransform = 2

	// 270 degrees counter-clockwise
	OutputTransform270 OutputTransform = 3

	// 180 degree flip around a vertical axis
	OutputTransformFlipped OutputTransform = 4

	// flip and rotate 90 degrees counter-clockwise
	OutputTransformFlipped90 OutputTransform = 5

	// flip and rotate 180 degrees counter-clockwise
	OutputTransformFlipped180 OutputTransform = 6

	// flip and rotate 270 degrees counter-clockwise
	OutputTransformFlipped270 OutputTransform = 7
)

func (enum OutputTransform) String() string {
	switch enum {
	case 0:
		return "OutputTransformNormal"

	case 1:
		return "OutputTransform90"

	case 2:
		return "OutputTransform180"

	case 3:
		return "OutputTransform270"

	case 4:
		return "OutputTransformFlipped"

	case 5:
		return "OutputTransformFlipped90"

	case 6:
		return "OutputTransformFlipped180"

	case 7:
		return "OutputTransformFlipped270"
	}

	return "<invalid OutputTransform>"
}

// These flags describe properties of an output mode.
// They are used in the flags bitfield of the mode event.
type OutputMode int64

const (
	// indicates this is the current mode
	OutputModeCurrent OutputMode = 1

	// indicates this is the preferred mode
	OutputModePreferred OutputMode = 2
)

func (enum OutputMode) String() string {
	switch enum {
	case 1:
		return "OutputModeCurrent"

	case 2:
		return "OutputModePreferred"
	}

	return "<invalid OutputMode>"
}

const (
	RegionInterface = "wl_region"
	RegionVersion   = 1
)

// RegionListener is a type that can respond to incoming
// messages for a Region object.
type RegionListener interface {
	// Destroy the region.  This will invalidate the object ID.
	Destroy()

	// Add the specified rectangle to the region.
	Add(x int32, y int32, width int32, height int32)

	// Subtract the specified rectangle from the region.
	Subtract(x int32, y int32, width int32, height int32)
}

// A region object describes an area.
//
// Region objects are used to describe the opaque and input
// regions of a surface.
type Region struct {
	// Listener's methods are called by incoming messages from the
	// remote end via Dispatch. If it is nil, messages are silently
	// ignored.
	Listener RegionListener

	// OnDelete is called when the object is removed from the tracking
	// system.
	OnDelete func()

	state wire.State
	id    uint32
}

// NewRegion returns a newly instantiated Region. It is
// primarily intended for use by generated code.
func NewRegion(state wire.State) *Region {
	return &Region{state: state}
}

func (obj *Region) State() wire.State {
	return obj.state
}

func (obj *Region) Dispatch(msg *wire.MessageBuffer) error {
	switch msg.Op() {
	case 0:
		if err := msg.Err(); err != nil {
			return err
		}

		if obj.Listener == nil {
			return nil
		}
		obj.Listener.Destroy()
		return nil

	case 1:

		x := msg.ReadInt()

		y := msg.ReadInt()

		width := msg.ReadInt()

		height := msg.ReadInt()

		if err := msg.Err(); err != nil {
			return err
		}

		if obj.Listener == nil {
			return nil
		}
		obj.Listener.Add(
			x,
			y,
			width,
			height,
		)
		return nil

	case 2:

		x := msg.ReadInt()

		y := msg.ReadInt()

		width := msg.ReadInt()

		height := msg.ReadInt()

		if err := msg.Err(); err != nil {
			return err
		}

		if obj.Listener == nil {
			return nil
		}
		obj.Listener.Subtract(
			x,
			y,
			width,
			height,
		)
		return nil
	}

	return wire.UnknownOpError{
		Interface: "wl_region",
		Type:      "request",
		Op:        msg.Op(),
	}
}

func (obj *Region) ID() uint32 {
	return obj.id
}

func (obj *Region) SetID(id uint32) {
	obj.id = id
}

func (obj *Region) Delete() {
	if obj.OnDelete != nil {
		obj.OnDelete()
	}
}

func (obj *Region) String() string {
	return fmt.Sprintf("%v(%v)", "wl_region", obj.id)
}

func (obj *Region) MethodName(op uint16) string {
	switch op {
	case 0:
		return "destroy"

	case 1:
		return "add"

	case 2:
		return "subtract"
	}

	return "unknown method"
}

func (obj *Region) Interface() string {
	return RegionInterface
}

func (obj *Region) Version() uint32 {
	return RegionVersion
}

const (
	SubcompositorInterface = "wl_subcompositor"
	SubcompositorVersion   = 1
)

// SubcompositorListener is a type that can respond to incoming
// messages for a Subcompositor object.
type SubcompositorListener interface {
	// Informs the server that the client will not be using this
	// protocol object anymore. This does not affect any other
	// objects, wl_subsurface objects included.
	Destroy()

	// Create a sub-surface interface for the given surface, and
	// associate it with the given parent surface. This turns a
	// plain wl_surface into a sub-surface.
	//
	// The to-be sub-surface must not already have another role, and it
	// must not have an existing wl_subsurface object. Otherwise a protocol
	// error is raised.
	//
	// Adding sub-surfaces to a parent is a double-buffered operation on the
	// parent (see wl_surface.commit). The effect of adding a sub-surface
	// becomes visible on the next time the state of the parent surface is
	// applied.
	//
	// This request modifies the behaviour of wl_surface.commit request on
	// the sub-surface, see the documentation on wl_subsurface interface.
	GetSubsurface(id *Subsurface, surface *Surface, parent *Surface)
}

// The global interface exposing sub-surface compositing capabilities.
// A wl_surface, that has sub-surfaces associated, is called the
// parent surface. Sub-surfaces can be arbitrarily nested and create
// a tree of sub-surfaces.
//
// The root surface in a tree of sub-surfaces is the main
// surface. The main surface cannot be a sub-surface, because
// sub-surfaces must always have a parent.
//
// A main surface with its sub-surfaces forms a (compound) window.
// For window management purposes, this set of wl_surface objects is
// to be considered as a single window, and it should also behave as
// such.
//
// The aim of sub-surfaces is to offload some of the compositing work
// within a window from clients to the compositor. A prime example is
// a video player with decorations and video in separate wl_surface
// objects. This should allow the compositor to pass YUV video buffer
// processing to dedicated overlay hardware when possible.
type Subcompositor struct {
	// Listener's methods are called by incoming messages from the
	// remote end via Dispatch. If it is nil, messages are silently
	// ignored.
	Listener SubcompositorListener

	// OnDelete is called when the object is removed from the tracking
	// system.
	OnDelete func()

	state wire.State
	id    uint32
}

// NewSubcompositor returns a newly instantiated Subcompositor. It is
// primarily intended for use by generated code.
func NewSubcompositor(state wire.State) *Subcompositor {
	return &Subcompositor{state: state}
}

func BindSubcompositor(state wire.State, id wire.NewID) *Subcompositor {
	obj := NewSubcompositor(state)
	obj.SetID(id.ID)
	state.Add(obj)
	return obj
}

func (obj *Subcompositor) State() wire.State {
	return obj.state
}

func (obj *Subcompositor) Dispatch(msg *wire.MessageBuffer) error {
	switch msg.Op() {
	case 0:
		if err := msg.Err(); err != nil {
			return err
		}

		if obj.Listener == nil {
			return nil
		}
		obj.Listener.Destroy()
		return nil

	case 1:
		id := NewSubsurface(obj.state)
		id.SetID(msg.ReadUint())
		obj.state.Add(id)

		surface := NewSurface(obj.state)
		surface.SetID(msg.ReadUint())
		obj.state.Add(surface)

		parent := NewSurface(obj.state)
		parent.SetID(msg.ReadUint())
		obj.state.Add(parent)

		if err := msg.Err(); err != nil {
			return err
		}

		if obj.Listener == nil {
			return nil
		}
		obj.Listener.GetSubsurface(
			id,
			surface,
			parent,
		)
		return nil
	}

	return wire.UnknownOpError{
		Interface: "wl_subcompositor",
		Type:      "request",
		Op:        msg.Op(),
	}
}

func (obj *Subcompositor) ID() uint32 {
	return obj.id
}

func (obj *Subcompositor) SetID(id uint32) {
	obj.id = id
}

func (obj *Subcompositor) Delete() {
	if obj.OnDelete != nil {
		obj.OnDelete()
	}
}

func (obj *Subcompositor) String() string {
	return fmt.Sprintf("%v(%v)", "wl_subcompositor", obj.id)
}

func (obj *Subcompositor) MethodName(op uint16) string {
	switch op {
	case 0:
		return "destroy"

	case 1:
		return "get_subsurface"
	}

	return "unknown method"
}

func (obj *Subcompositor) Interface() string {
	return SubcompositorInterface
}

func (obj *Subcompositor) Version() uint32 {
	return SubcompositorVersion
}

type SubcompositorError int64

const (
	// the to-be sub-surface is invalid
	SubcompositorErrorBadSurface SubcompositorError = 0
)

func (enum SubcompositorError) String() string {
	switch enum {
	case 0:
		return "SubcompositorErrorBadSurface"
	}

	return "<invalid SubcompositorError>"
}

const (
	SubsurfaceInterface = "wl_subsurface"
	SubsurfaceVersion   = 1
)

// SubsurfaceListener is a type that can respond to incoming
// messages for a Subsurface object.
type SubsurfaceListener interface {
	// The sub-surface interface is removed from the wl_surface object
	// that was turned into a sub-surface with a
	// wl_subcompositor.get_subsurface request. The wl_surface's association
	// to the parent is deleted, and the wl_surface loses its role as
	// a sub-surface. The wl_surface is unmapped immediately.
	Destroy()

	// This schedules a sub-surface position change.
	// The sub-surface will be moved so that its origin (top left
	// corner pixel) will be at the location x, y of the parent surface
	// coordinate system. The coordinates are not restricted to the parent
	// surface area. Negative values are allowed.
	//
	// The scheduled coordinates will take effect whenever the state of the
	// parent surface is applied. When this happens depends on whether the
	// parent surface is in synchronized mode or not. See
	// wl_subsurface.set_sync and wl_subsurface.set_desync for details.
	//
	// If more than one set_position request is invoked by the client before
	// the commit of the parent surface, the position of a new request always
	// replaces the scheduled position from any previous request.
	//
	// The initial position is 0, 0.
	SetPosition(x int32, y int32)

	// This sub-surface is taken from the stack, and put back just
	// above the reference surface, changing the z-order of the sub-surfaces.
	// The reference surface must be one of the sibling surfaces, or the
	// parent surface. Using any other surface, including this sub-surface,
	// will cause a protocol error.
	//
	// The z-order is double-buffered. Requests are handled in order and
	// applied immediately to a pending state. The final pending state is
	// copied to the active state the next time the state of the parent
	// surface is applied. When this happens depends on whether the parent
	// surface is in synchronized mode or not. See wl_subsurface.set_sync and
	// wl_subsurface.set_desync for details.
	//
	// A new sub-surface is initially added as the top-most in the stack
	// of its siblings and parent.
	PlaceAbove(sibling *Surface)

	// The sub-surface is placed just below the reference surface.
	// See wl_subsurface.place_above.
	PlaceBelow(sibling *Surface)

	// Change the commit behaviour of the sub-surface to synchronized
	// mode, also described as the parent dependent mode.
	//
	// In synchronized mode, wl_surface.commit on a sub-surface will
	// accumulate the committed state in a cache, but the state will
	// not be applied and hence will not change the compositor output.
	// The cached state is applied to the sub-surface immediately after
	// the parent surface's state is applied. This ensures atomic
	// updates of the parent and all its synchronized sub-surfaces.
	// Applying the cached state will invalidate the cache, so further
	// parent surface commits do not (re-)apply old state.
	//
	// See wl_subsurface for the recursive effect of this mode.
	SetSync()

	// Change the commit behaviour of the sub-surface to desynchronized
	// mode, also described as independent or freely running mode.
	//
	// In desynchronized mode, wl_surface.commit on a sub-surface will
	// apply the pending state directly, without caching, as happens
	// normally with a wl_surface. Calling wl_surface.commit on the
	// parent surface has no effect on the sub-surface's wl_surface
	// state. This mode allows a sub-surface to be updated on its own.
	//
	// If cached state exists when wl_surface.commit is called in
	// desynchronized mode, the pending state is added to the cached
	// state, and applied as a whole. This invalidates the cache.
	//
	// Note: even if a sub-surface is set to desynchronized, a parent
	// sub-surface may override it to behave as synchronized. For details,
	// see wl_subsurface.
	//
	// If a surface's parent surface behaves as desynchronized, then
	// the cached state is applied on set_desync.
	SetDesync()
}

// An additional interface to a wl_surface object, which has been
// made a sub-surface. A sub-surface has one parent surface. A
// sub-surface's size and position are not limited to that of the parent.
// Particularly, a sub-surface is not automatically clipped to its
// parent's area.
//
// A sub-surface becomes mapped, when a non-NULL wl_buffer is applied
// and the parent surface is mapped. The order of which one happens
// first is irrelevant. A sub-surface is hidden if the parent becomes
// hidden, or if a NULL wl_buffer is applied. These rules apply
// recursively through the tree of surfaces.
//
// The behaviour of a wl_surface.commit request on a sub-surface
// depends on the sub-surface's mode. The possible modes are
// synchronized and desynchronized, see methods
// wl_subsurface.set_sync and wl_subsurface.set_desync. Synchronized
// mode caches the wl_surface state to be applied when the parent's
// state gets applied, and desynchronized mode applies the pending
// wl_surface state directly. A sub-surface is initially in the
// synchronized mode.
//
// Sub-surfaces also have another kind of state, which is managed by
// wl_subsurface requests, as opposed to wl_surface requests. This
// state includes the sub-surface position relative to the parent
// surface (wl_subsurface.set_position), and the stacking order of
// the parent and its sub-surfaces (wl_subsurface.place_above and
// .place_below). This state is applied when the parent surface's
// wl_surface state is applied, regardless of the sub-surface's mode.
// As the exception, set_sync and set_desync are effective immediately.
//
// The main surface can be thought to be always in desynchronized mode,
// since it does not have a parent in the sub-surfaces sense.
//
// Even if a sub-surface is in desynchronized mode, it will behave as
// in synchronized mode, if its parent surface behaves as in
// synchronized mode. This rule is applied recursively throughout the
// tree of surfaces. This means, that one can set a sub-surface into
// synchronized mode, and then assume that all its child and grand-child
// sub-surfaces are synchronized, too, without explicitly setting them.
//
// If the wl_surface associated with the wl_subsurface is destroyed, the
// wl_subsurface object becomes inert. Note, that destroying either object
// takes effect immediately. If you need to synchronize the removal
// of a sub-surface to the parent surface update, unmap the sub-surface
// first by attaching a NULL wl_buffer, update parent, and then destroy
// the sub-surface.
//
// If the parent wl_surface object is destroyed, the sub-surface is
// unmapped.
type Subsurface struct {
	// Listener's methods are called by incoming messages from the
	// remote end via Dispatch. If it is nil, messages are silently
	// ignored.
	Listener SubsurfaceListener

	// OnDelete is called when the object is removed from the tracking
	// system.
	OnDelete func()

	state wire.State
	id    uint32
}

// NewSubsurface returns a newly instantiated Subsurface. It is
// primarily intended for use by generated code.
func NewSubsurface(state wire.State) *Subsurface {
	return &Subsurface{state: state}
}

func (obj *Subsurface) State() wire.State {
	return obj.state
}

func (obj *Subsurface) Dispatch(msg *wire.MessageBuffer) error {
	switch msg.Op() {
	case 0:
		if err := msg.Err(); err != nil {
			return err
		}

		if obj.Listener == nil {
			return nil
		}
		obj.Listener.Destroy()
		return nil

	case 1:

		x := msg.ReadInt()

		y := msg.ReadInt()

		if err := msg.Err(); err != nil {
			return err
		}

		if obj.Listener == nil {
			return nil
		}
		obj.Listener.SetPosition(
			x,
			y,
		)
		return nil

	case 2:
		sibling := NewSurface(obj.state)
		sibling.SetID(msg.ReadUint())
		obj.state.Add(sibling)

		if err := msg.Err(); err != nil {
			return err
		}

		if obj.Listener == nil {
			return nil
		}
		obj.Listener.PlaceAbove(
			sibling,
		)
		return nil

	case 3:
		sibling := NewSurface(obj.state)
		sibling.SetID(msg.ReadUint())
		obj.state.Add(sibling)

		if err := msg.Err(); err != nil {
			return err
		}

		if obj.Listener == nil {
			return nil
		}
		obj.Listener.PlaceBelow(
			sibling,
		)
		return nil

	case 4:
		if err := msg.Err(); err != nil {
			return err
		}

		if obj.Listener == nil {
			return nil
		}
		obj.Listener.SetSync()
		return nil

	case 5:
		if err := msg.Err(); err != nil {
			return err
		}

		if obj.Listener == nil {
			return nil
		}
		obj.Listener.SetDesync()
		return nil
	}

	return wire.UnknownOpError{
		Interface: "wl_subsurface",
		Type:      "request",
		Op:        msg.Op(),
	}
}

func (obj *Subsurface) ID() uint32 {
	return obj.id
}

func (obj *Subsurface) SetID(id uint32) {
	obj.id = id
}

func (obj *Subsurface) Delete() {
	if obj.OnDelete != nil {
		obj.OnDelete()
	}
}

func (obj *Subsurface) String() string {
	return fmt.Sprintf("%v(%v)", "wl_subsurface", obj.id)
}

func (obj *Subsurface) MethodName(op uint16) string {
	switch op {
	case 0:
		return "destroy"

	case 1:
		return "set_position"

	case 2:
		return "place_above"

	case 3:
		return "place_below"

	case 4:
		return "set_sync"

	case 5:
		return "set_desync"
	}

	return "unknown method"
}

func (obj *Subsurface) Interface() string {
	return SubsurfaceInterface
}

func (obj *Subsurface) Version() uint32 {
	return SubsurfaceVersion
}

type SubsurfaceError int64

const (
	// wl_surface is not a sibling or the parent
	SubsurfaceErrorBadSurface SubsurfaceError = 0
)

func (enum SubsurfaceError) String() string {
	switch enum {
	case 0:
		return "SubsurfaceErrorBadSurface"
	}

	return "<invalid SubsurfaceError>"
}
